{"version":3,"sources":["sanjo:meteor-files-helpers/lib/meteor/files.js","sanjo:meteor-files-helpers/meteor_files_helpers.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,G;AACA,qC;AACA,E;AACA,Y;AACA,qC;AACA,G;;AAEA,+B;AACA,2B;;AAEA,mE;AACA,mE;AACA,E;AACA,oE;AACA,qE;AACA,O;AACA,mD;AACA,2C;AACA,mB;AACA,6B;AACA,Y;AACA,K;AACA,uC;AACA,6B;AACA,qB;AACA,Y;AACA,uB;AACA,K;AACA,G;AACA,e;AACA,gB;;AAEA,iB;AACA,E;;AAEA,qE;AACA,wD;AACA,kC;AACA,sC;AACA,sE;AACA,sE;AACA,mB;;AAEA,qE;AACA,qE;AACA,uE;AACA,wE;AACA,2E;AACA,8E;AACA,iB;AACA,mB;AACA,K;AACA,I;;AAEA,yC;AACA,E;;;;;;;;;;;;;;;;;;;ACvDA,8B;AACA,0B;AACA,gD;AACA,yD;AACA,qC;AACA,0B;AACA,I;AACA,E;;AAEA,sB;AACA,2B;AACA,+B;AACA,kD;AACA,I;;AAEA,kC;AACA,sB;AACA,4D;AACA,Y;AACA,+B;AACA,K;AACA,I;;AAEA,0C;AACA,kB;AACA,sB;AACA,kD;AACA,uD;AACA,gE;AACA,O;;AAEA,Y;AACA,sF;AACA,K;;AAEA,qB;AACA,I;;AAEA,mE;AACA,qC;AACA,sC;AACA,qC;AACA,uD;AACA,K;AACA,mC;AACA,+E;AACA,Y;AACA,wB;AACA,yB;AACA,yD;AACA,qB;AACA,qH;AACA,+C;AACA,S;AACA,c;AACA,yB;AACA,0C;AACA,4D;AACA,mE;AACA,wC;AACA,S;AACA,O;AACA,K;AACA,I;;AAEA,6C;AACA,qC;AACA,4D;AACA,K;AACA,wE;AACA,yB;AACA,8E;AACA,8C;AACA,gC;AACA,mC;AACA,gD;AACA,M;;AAEA,uB;AACA,K;;AAEA,6C;AACA,iE;;AAEA,uC;AACA,I;;AAEA,0E;AACA,gC;AACA,qD;AACA,iB;AACA,uD;AACA,K;;AAEA,+B;AACA,gE;AACA,K;;AAEA,8B;AACA,G;AACA,C;;AAEA,sB;AACA,qC;AACA,C;;AAEA,4D;AACA,wD;AACA,6E;AACA,uB;AACA,uC;AACA,C","file":"/packages/sanjo_meteor-files-helpers.js","sourcesContent":["/**\n * Copied from Meteor tools/files.js.\n *\n * Includes:\n * - Helper to find the app root path\n */\n\nvar path = Npm.require('path');\nvar fs = Npm.require('fs');\n\n// given a predicate function and a starting path, traverse upwards\n// from the path until we find a path that satisfies the predicate.\n//\n// returns either the path to the lowest level directory that passed\n// the test or null for none found. if starting path isn't given, use\n// cwd.\nvar findUpwards = function (predicate, startPath) {\n  var testDir = startPath || process.cwd();\n  while (testDir) {\n    if (predicate(testDir)) {\n      break;\n    }\n    var newDir = path.dirname(testDir);\n    if (newDir === testDir) {\n      testDir = null;\n    } else {\n      testDir = newDir;\n    }\n  }\n  if (!testDir)\n    return null;\n\n  return testDir;\n};\n\n// Determine if 'filepath' (a path, or omit for cwd) is within an app\n// directory. If so, return the top-level app directory.\nfindAppDir = function (filepath) {\n  var isAppDir = function (filepath) {\n    // XXX once we are done with the transition to engine, this should\n    // change to: `return fs.existsSync(path.join(filepath, '.meteor',\n    // 'release'))`\n\n    // .meteor/packages can be a directory, if .meteor is a warehouse\n    // directory.  since installing meteor initializes a warehouse at\n    // $HOME/.meteor, we want to make sure your home directory (and all\n    // subdirectories therein) don't count as being within a meteor app.\n    try { // use try/catch to avoid the additional syscall to fs.existsSync\n      return fs.statSync(path.join(filepath, '.meteor', 'packages')).isFile();\n    } catch (e) {\n      return false;\n    }\n  };\n\n  return findUpwards(isAppDir, filepath);\n};\n","var path = Npm.require('path')\nvar fs = Npm.require('fs')\nvar readFile = Meteor.wrapAsync(fs.readFile, fs)\nvar exists = Meteor.wrapAsync(function (path, callback) {\n  fs.exists(path, function (result) {\n    callback(null, result)\n  })\n})\n\nMeteorFilesHelpers = {\n  getAppPath: function () {\n    var appPath = findAppDir();\n    return appPath ? path.resolve(appPath) : null;\n  },\n\n  getMeteorToolPath: function () {\n    if (isWindows()) {\n      return path.resolve(process.env.NODE_PATH, '../../..')\n    } else {\n      return process.env.OLDPWD\n    }\n  },\n\n  getMeteorInstallationPath: function () {\n    var meteorPath\n    if (isWindows()) {\n      meteorPath = process.env.METEOR_INSTALLATION\n      if (meteorPath[meteorPath.length - 1] === '\\\\') {\n        meteorPath = meteorPath.substr(0, meteorPath.length - 1)\n      }\n\n    } else {\n      meteorPath = path.resolve(MeteorFilesHelpers.getMeteorToolPath(), '../../../..')\n    }\n\n    return meteorPath\n  },\n\n  getNodeModulePath: function (meteorPackageName, nodeModuleName) {\n    var localIsopackPath = path.join(\n      MeteorFilesHelpers.getAppPath(),\n      '.meteor', 'local', 'isopacks',\n      getFilesystemMeteorPackageName(meteorPackageName)\n    )\n    if (exists(localIsopackPath)) {\n      return path.join(localIsopackPath, 'npm', 'node_modules', nodeModuleName)\n    } else {\n      if (isWindows()) {\n        return path.join(\n          MeteorFilesHelpers.getMeteorInstallationPath(),\n          'packages',\n          getFilesystemMeteorPackageName(meteorPackageName), MeteorFilesHelpers.getPackageVersion(meteorPackageName),\n          'npm', 'node_modules', nodeModuleName\n        )\n      } else {\n        return path.join(\n          MeteorFilesHelpers.getAppPath(),\n          '.meteor', 'local', 'build', 'programs', 'server',\n          'npm', getFilesystemMeteorPackageName(meteorPackageName),\n          'node_modules', nodeModuleName\n        )\n      }\n    }\n  },\n\n  getPackageVersions: _.memoize(function () {\n    var versionsFilePath = path.join(\n      MeteorFilesHelpers.getAppPath(), '.meteor', 'versions'\n    )\n    var versionsContent = readFile(versionsFilePath, {encoding: 'utf8'})\n    var versionsHash = {}\n    versionsContent.split(/\\r\\n|\\r|\\n/).forEach(function (packageConstraint) {\n      var parts = packageConstraint.split('@')\n      var packageName = parts[0]\n      var packageVersion = parts[1]\n      versionsHash[packageName] = packageVersion\n    })\n\n    return versionsHash\n  }),\n\n  getPackageVersion: function (packageName) {\n    var packageVersions = MeteorFilesHelpers.getPackageVersions()\n\n    return packageVersions[packageName]\n  },\n\n  isPackageInstalled: function (meteorPackageName, meteorPackageVersion) {\n    var packagePath = path.join(\n      MeteorFilesHelpers.getMeteorInstallationPath(),\n      'packages',\n      getFilesystemMeteorPackageName(meteorPackageName)\n    )\n\n    if (meteorPackageVersion) {\n      packagePath = path.join(packagePath, meteorPackageVersion)\n    }\n\n    return exists(packagePath)\n  }\n}\n\nfunction isWindows() {\n  return process.platform === 'win32'\n}\n\nfunction getFilesystemMeteorPackageName(meteorPackageName) {\n  var meteorVersion = MeteorVersion.getSemanticVersion()\n  return (meteorVersion && PackageVersion.lessThan(meteorVersion, '1.0.4')) ?\n    meteorPackageName :\n    meteorPackageName.replace(':', '_')\n}\n"]}