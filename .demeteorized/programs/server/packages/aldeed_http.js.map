{"version":3,"sources":["aldeed:http/http-extras-common.js","aldeed:http/http-extras-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,mD;AACA,+E;;AAEA,wC;AACA,oE;AACA,I;;AAEA,8C;AACA,gB;AACA,S;AACA,yE;AACA,K;AACA,mB;AACA,oD;AACA,K;AACA,G;;AAEA,4B;AACA,E;;AAEA,iC;AACA,e;AACA,uC;AACA,mB;AACA,oB;AACA,0D;AACA,K;AACA,2C;AACA,E;;AAEA,8B;AACA,kF;AACA,E;;AAEA,sE;AACA,uC;AACA,sD;;AAEA,oC;AACA,8B;;AAEA,mB;AACA,wB;AACA,wC;AACA,sB;AACA,mB;AACA,kB;AACA,G;;AAEA,8B;AACA,qB;AACA,uB;;AAEA,a;AACA,E;;AAEA,uD;AACA,mC;AACA,2D;AACA,gE;AACA,gC;AACA,4E;;AAEA,wE;AACA,wE;AACA,S;AACA,mD;AACA,mB;AACA,2B;AACA,K;AACA,U;AACA,yB;AACA,G;AACA,E;;;;;;;;;;;;;;;;;;;ACzEA,qC;AACA,kC;;AAEA,8D;AACA,mE;AACA,sD;;AAEA,yC;;AAEA,oD;AACA,oD;AACA,uB;AACA,mB;AACA,G;;AAEA,0B;;AAEA,wC;;AAEA,iC;AACA,+E;;AAEA,sC;;AAEA,mB;;AAEA,gC;AACA,qB;AACA,2C;AACA,iD;AACA,G;;AAEA,sD;AACA,+E;;AAEA,sE;AACA,oD;AACA,4E;AACA,oB;AACA,G;;AAEA,sC;AACA,uD;AACA,oC;AACA,M;AACA,qC;;AAEA,yB;AACA,oE;AACA,qD;;AAEA,qB;AACA,sC;AACA,+E;AACA,wC;AACA,6D;AACA,G;;AAEA,wB;AACA,4C;AACA,kE;AACA,G;;AAEA,2C;;AAEA,oE;AACA,oE;AACA,kC;AACA,sC;AACA,4B;AACA,kC;AACA,gC;AACA,M;AACA,e;;AAEA,8C;AACA,8B;;;AAGA,gC;;AAEA,qB;AACA,iB;AACA,mB;AACA,uB;AACA,e;AACA,6B;AACA,kB;AACA,4C;AACA,oB;AACA,I;;AAEA,mD;AACA,wB;;AAEA,kB;;AAEA,oB;AACA,2C;;AAEA,yC;AACA,6B;AACA,2B;AACA,gC;AACA,wC;AACA,wC;AACA,yC;AACA,8B;AACA,W;AACA,oB;AACA,gB;AACA,4B;AACA,gC;AACA,4C;AACA,yC;AACA,gC;AACA,W;AACA,wB;AACA,gB;AACA,oB;AACA,yC;AACA,iB;AACA,sC;AACA,2B;AACA,qC;AACA,a;AACA,W;AACA,gB;AACA,O;;;AAGA,8B;AACA,qC;;AAEA,6B;;AAEA,qC;AACA,yE;AACA,K;;AAEA,8B;;AAEA,K;AACA,E;;AAEA,oC","file":"/packages/aldeed:http.js","sourcesContent":["makeErrorByStatus = function(statusCode, content) {\n  var MAX_LENGTH = 500; // if you change this, also change the appropriate test\n\n  var truncate = function(str, length) {\n    return str.length > length ? str.slice(0, length) + '...' : str;\n  };\n\n  var message = \"failed [\" + statusCode + \"]\";\n  if (content) {\n    try {\n      message += \" \" + truncate(content.replace(/\\n/g, \" \"), MAX_LENGTH);\n    }\n    catch (error) {\n      message += \" Response is not of type String \";\n    }\n  }\n\n  return new Error(message);\n};\n\nencodeParams = function(params) {\n  var buf = [];\n  _.each(params, function(value, key) {\n    if (buf.length)\n      buf.push('&');\n    buf.push(encodeString(key), '=', encodeString(value));\n  });\n  return buf.join('').replace(/%20/g, '+');\n};\n\nencodeString = function(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\nbuildUrl = function(before_qmark, from_qmark, opt_query, opt_params) {\n  var url_without_query = before_qmark;\n  var query = from_qmark ? from_qmark.slice(1) : null;\n\n  if (typeof opt_query === \"string\")\n    query = String(opt_query);\n\n  if (opt_params) {\n    query = query || \"\";\n    var prms = encodeParams(opt_params);\n    if (query && prms)\n      query += '&';\n    query += prms;\n  }\n\n  var url = url_without_query;\n  if (query !== null)\n    url += (\"?\"+query);\n\n  return url;\n};\n\n// Fill in `response.data` if the content-type is JSON.\npopulateData = function(response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\n\n  // Only try to parse data as JSON if server sets correct content type.\n  if (_.include(['application/json', 'text/javascript'], contentType)) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n","var request = Npm.require('request');\nvar url_util = Npm.require('url');\n\n// _call always runs asynchronously; HTTP.call, defined below,\n// wraps _call and runs synchronously when no callback is provided.\nvar _call = function(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  method = (method || \"\").toUpperCase();\n\n  if (! /^https?:\\/\\//.test(url))\n    throw new Error(\"url must be absolute and start with http:// or https://\");\n\n  var url_parts = url_util.parse(url);\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  var responseType = options.responseType || \"string\";\n  var encoding = _.isUndefined(options._encoding) ? \"utf8\" : options._encoding;\n\n  // If responseType requires getting a Buffer back, override encoding\n  // to null, which tells request to return a Buffer\n  if (_.contains([\"arraybuffer\", \"buffer\", \"ejson-binary\"], responseType)) {\n    encoding = null;\n  }\n\n  var params_for_url, params_for_body;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    params_for_url = options.params;\n  else\n    params_for_body = options.params;\n\n  var new_url = buildUrl(\n    url_parts.protocol + \"//\" + url_parts.host + url_parts.pathname,\n    url_parts.search, options.query, params_for_url);\n\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    headers['Authorization'] = \"Basic \"+\n      (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n  }\n\n  if (params_for_body) {\n    content = encodeParams(params_for_body);\n    headers['Content-Type'] = \"application/x-www-form-urlencoded\";\n  }\n\n  _.extend(headers, options.headers || {});\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    return function(error, response) {\n      if (error && response)\n        error.response = response;\n      callback(error, response);\n    };\n  })(callback);\n\n  // safety belt: only call the callback once.\n  callback = _.once(callback);\n\n\n  ////////// Kickoff! //////////\n\n  var req_options = {\n    url: new_url,\n    method: method,\n    encoding: encoding,\n    jar: false,\n    timeout: options.timeout,\n    body: content,\n    followRedirect: options.followRedirects,\n    headers: headers\n  };\n\n  request(req_options, function(error, res, body) {\n    var response = null;\n\n    if (! error) {\n\n      response = {};\n      response.statusCode = res.statusCode;\n\n      // Convert body into requested type\n      switch (responseType) {\n        case \"arraybuffer\":\n          var len = body.length;\n          var ab = new ArrayBuffer(len);\n          var view = new Uint8Array(ab);\n          for (var i = 0; i < len; i++) {\n            view[i] = body[i];\n          }\n          body = ab;\n          break;\n        case \"ejson-binary\":\n          var len = body.length;\n          var binary = EJSON.newBinary(len);\n          for (var i = 0; i < len; i++) {\n            binary[i] = body[i];\n          }\n          body = binary;\n          break;\n        case \"json\":\n          if (typeof body === \"string\") {\n            try {\n              body = JSON.parse(body);\n            } catch (err) {\n              // leave it as a string\n            }\n          }\n          break;\n      }\n\n\n      response.content = body;\n      response.headers = res.headers;\n\n      populateData(response);\n\n      if (response.statusCode >= 400)\n        error = makeErrorByStatus(response.statusCode, response.content);\n    }\n\n    callback(error, response);\n\n  });\n};\n\nHTTP.call = Meteor.wrapAsync(_call);\n\n"]}