{"version":3,"sources":["telescope:post-by-feed/lib/feeds.js","telescope:post-by-feed/lib/server/fetch_feeds.js","telescope:post-by-feed/lib/server/cron.js","telescope:post-by-feed/lib/server/publications.js","telescope:post-by-feed//Users/sacha/Dev/Telescope/packages/telescope-post-by-feed/i18n/en.i18n.json"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,sC;;AAEA,iC;AACA,Q;AACA,iB;AACA,kC;AACA,yB;AACA,I;AACA,W;AACA,iB;AACA,sB;AACA,0B;AACA,e;AACA,2D;AACA,4B;AACA,6D;AACA,kB;AACA,4B;AACA,6C;AACA,Y;AACA,W;AACA,qB;AACA,O;AACA,K;AACA,I;AACA,e;AACA,mB;AACA,wB;AACA,mB;AACA,0B;AACA,e;AACA,+D;AACA,qB;AACA,qB;AACA,4B;AACA,oE;AACA,kB;AACA,gC;AACA,gC;AACA,Y;AACA,W;AACA,0B;AACA,O;AACA,K;AACA,G;AACA,G;;;AAGA,gC;;AAEA,iC;;AAEA,4D;AACA,sB;AACA,sB;AACA,gB;AACA,iB;AACA,oB;AACA,mB;AACA,e;AACA,gB;AACA,K;AACA,G;AACA,E;AACA,+B;;AAEA,8C;AACA,0B;AACA,0B;AACA,gB;AACA,iB;AACA,wB;AACA,mB;AACA,e;AACA,gB;AACA,K;AACA,G;AACA,E;AACA,mC;;AAEA,4B;AACA,e;AACA,+B;AACA,+B;AACA,8B;AACA,K;;AAEA,kB;AACA,kC;AACA,mC;;AAEA,4C;AACA,gF;;AAEA,2D;AACA,gH;;AAEA,mC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;ACpGA,uD;AACA,2B;AACA,2C;AACA,8C;AACA,sC;;AAEA,oC;AACA,uE;AACA,E;;AAEA,kD;AACA,gD;AACA,e;AACA,yC;;AAEA,sD;AACA,uB;AACA,gF;AACA,8B;AACA,yF;AACA,K;AACA,G;;AAEA,uD;AACA,S;AACA,sD;AACA,mB;AACA,8D;AACA,K;AACA,G;;AAEA,iB;AACA,E;;AAEA,mB;AACA,gC;AACA,gC;AACA,yB;AACA,sB;;AAEA,kB;AACA,I;;AAEA,qD;;AAEA,4B;;AAEA,kE;AACA,wD;AACA,8C;;AAEA,0E;AACA,4E;AACA,uB;AACA,4C;AACA,S;;AAEA,S;AACA,K;;AAEA,gF;AACA,2B;AACA,qE;AACA,K;;AAEA,0B;AACA,I;;AAEA,mE;AACA,mD;AACA,yC;AACA,kC;AACA,sB;AACA,gB;;AAEA,4B;;AAEA,iE;AACA,yD;AACA,Q;;AAEA,mE;AACA,2B;AACA,Q;;AAEA,iE;AACA,yB;;AAEA,+B;AACA,0D;AACA,yB;AACA,gC;AACA,S;;AAEA,uC;AACA,uD;AACA,yD;AACA,mB;AACA,S;;AAEA,wB;;AAEA,oB;AACA,uC;AACA,yB;AACA,yB;AACA,gC;AACA,yB;AACA,kE;AACA,U;;AAEA,6B;AACA,8D;;AAEA,4B;;AAEA,yE;AACA,gE;AACA,qF;AACA,sD;AACA,8C;AACA,a;;AAEA,yC;AACA,yB;AACA,wD;;AAEA,a;AACA,6B;AACA,yB;AACA,qD;AACA,+B;AACA,S;AACA,O;;AAEA,wE;AACA,mB;AACA,kD;AACA,oB;AACA,G;AACA,E;;AAEA,yB;AACA,oB;;AAEA,uC;;AAEA,uD;AACA,uE;AACA,yC;AACA,0B;;AAEA,S;AACA,2E;AACA,wE;AACA,qB;AACA,yB;AACA,8C;AACA,K;AACA,K;AACA,E;;AAEA,gB;AACA,2B;AACA,iB;AACA,I;AACA,iC;AACA,iC;AACA,I;AACA,mC;AACA,kC;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;AC5KA,sB;AACA,a;AACA,gC;AACA,c;AACA,uB;AACA,C;;AAEA,0B;AACA,kB;AACA,6B;AACA,gC;AACA,6C;AACA,O;AACA,qB;AACA,iC;AACA,qB;AACA,O;AACA,K;AACA,K;AACA,C;;AAEA,4B;AACA,W;AACA,E;;;;;;;;;;;;;;;;;;;ACvBA,oC;AACA,sC;AACA,wB;AACA,G;AACA,Y;AACA,G;;;;;;;;;;;;;;;;;;;ACLA,6B;AACA,6B;AACA,0B;;AAEA,gC;AACA,yD;AACA,C;AACA,+G;AACA,sD;AACA,gD;AACA,kB;AACA,wQ;AACA,gD","file":"/packages/telescope_post-by-feed.js","sourcesContent":["Feeds = new Mongo.Collection('feeds');\n\nFeeds.schema = new SimpleSchema({\n  url: {\n    type: String,\n    regEx: SimpleSchema.RegEx.Url,\n    editableBy: [\"admin\"]\n  },\n  userId: {\n    type: String,\n    label: 'feedUser',\n    editableBy: [\"admin\"],\n    autoform: {\n      instructions: 'Posts will be assigned to this user.',\n      options: function () {\n        var users = Meteor.users.find().map(function (user) {\n          return {\n            value: user._id,\n            label: Users.getDisplayName(user)\n          };\n        });\n        return users;\n      }\n    }\n  },\n  categories: {\n    type: [String],\n    label: 'categories',\n    optional: true,\n    editableBy: [\"admin\"],\n    autoform: {\n      instructions: 'Posts will be assigned to this category.',\n      noselect: true,\n      editable: true,\n      options: function () {\n        var categories = Categories.find().map(function (category) {\n          return {\n            value: category._id,\n            label: category.name\n          };\n        });\n        return categories;\n      }\n    }\n  }\n});\n\n\nFeeds.schema.internationalize();\n\nFeeds.attachSchema(Feeds.schema);\n\n// used to keep track of which feed a post was imported from\nvar feedIdProperty = {\n  fieldName: 'feedId',\n  fieldSchema: {\n    type: String,\n    label: 'feedId',\n    optional: true,\n    autoform: {\n      omit: true\n    }\n  }\n};\nPosts.addField(feedIdProperty);\n\n// the RSS ID of the post in its original feed\nvar feedItemIdProperty = {\n  fieldName: 'feedItemId',\n  fieldSchema: {\n    type: String,\n    label: 'feedItemId',\n    optional: true,\n    autoform: {\n      omit: true\n    }\n  }\n};\nPosts.addField(feedItemIdProperty);\n\nMeteor.startup(function () {\n  Feeds.allow({\n    insert: Users.is.adminById,\n    update: Users.is.adminById,\n    remove: Users.is.adminById\n  });\n\n  Meteor.methods({\n    insertFeed: function(feedUrl){\n      check(feedUrl, Feeds.schema);\n\n      if (Feeds.findOne({url: feedUrl.url}))\n        throw new Meteor.Error('already-exists', i18n.t('feed_already_exists'));\n\n      if (!Meteor.user() || !Users.is.admin(Meteor.user()))\n        throw new Meteor.Error('login-required', i18n.t('you_need_to_login_and_be_an_admin_to_add_a_new_feed'));\n\n      return Feeds.insert(feedUrl);\n    }\n  });\n});\n","var toMarkdown = Npm.require('to-markdown').toMarkdown;\nvar he = Npm.require('he');\nvar FeedParser = Npm.require('feedparser');\nvar Readable = Npm.require('stream').Readable;\nvar iconv = Npm.require('iconv-lite');\n\nvar getFirstAdminUser = function() {\n  return Meteor.users.findOne({isAdmin: true}, {sort: {createdAt: 1}});\n};\n\nvar normalizeEncoding = function (contentBuffer) {\n  // got from https://github.com/szwacz/sputnik/\n  var encoding;\n  var content = contentBuffer.toString();\n\n  var xmlDeclaration = content.match(/^<\\?xml .*\\?>/);\n  if (xmlDeclaration) {\n    var encodingDeclaration = xmlDeclaration[0].match(/encoding=(\"|').*?(\"|')/);\n    if (encodingDeclaration) {\n      encoding = encodingDeclaration[0].substring(10, encodingDeclaration[0].length - 1);\n    }\n  }\n\n  if (encoding && encoding.toLowerCase() !== 'utf-8') {\n    try {\n      content = iconv.decode(contentBuffer, encoding);\n    } catch (err) {\n      // detected encoding is not supported, leave it as it is\n    }\n  }\n\n  return content;\n};\n\nvar feedHandler = {\n  getStream: function(content) {\n    var stream = new Readable();\n    stream.push(content);\n    stream.push(null);\n\n    return stream;\n  },\n\n  getItemCategories: function(item, feedCategories) {\n\n    var itemCategories = [];\n\n    // loop over RSS categories for the current item if it has any\n    if (item.categories && item.categories.length > 0) {\n      item.categories.forEach(function(name) {\n\n        // if the RSS category corresponds to a Telescope cateogry, add it\n        var category = Categories.findOne({name: name}, {fields: {_id: 1}});\n        if (category) {\n          itemCategories.push(category._id);\n        }\n\n      });\n    }\n\n    // add predefined feed categories if there are any and remove any duplicates\n    if (!!feedCategories) {\n      itemCategories = _.uniq(itemCategories.concat(feedCategories));\n    }\n\n    return itemCategories;\n  },\n\n  handle: function(contentBuffer, userId, feedCategories, feedId) {\n    var content = normalizeEncoding(contentBuffer);\n    var stream = this.getStream(content),\n    feedParser = new FeedParser(),\n    newItemsCount = 0,\n    self = this;\n\n    stream.pipe(feedParser);\n\n    feedParser.on('meta', Meteor.bindEnvironment(function(meta) {\n      Telescope.log('// Parsing RSS feed: '+ meta.title);\n    }));\n\n    feedParser.on('error', Meteor.bindEnvironment(function(error) {\n      Telescope.log(error);\n    }));\n\n    feedParser.on('readable', Meteor.bindEnvironment(function() {\n      var s = this, item;\n\n      while (item = s.read()) {\n        // if item has no guid, use the URL to give it one\n        if (!item.guid) {\n          item.guid = item.link;\n        }\n\n        // check if post already exists\n        if (!!Posts.findOne({feedItemId: item.guid})) {\n          Telescope.log('// Feed item already imported');\n          continue;\n        }\n\n        newItemsCount++;\n\n        var post = {\n          title: he.decode(item.title),\n          url: item.link,\n          feedId: feedId,\n          feedItemId: item.guid,\n          userId: userId,\n          categories: self.getItemCategories(item, feedCategories)\n        };\n\n        if (item.description)\n          post.body = toMarkdown(he.decode(item.description));\n\n        // console.log(item)\n\n        // if RSS item link is a 301 or 302 redirect, follow the redirect\n        var get = HTTP.get(item.link, {followRedirects: false});\n        if (!!get.statusCode && (get.statusCode === 301 || get.statusCode === 302) &&\n            !!get.headers && !!get.headers.location) {\n              post.url = get.headers.location;\n            }\n\n        // if RSS item has a date, use it\n        if (item.pubdate)\n          post.postedAt = moment(item.pubdate).toDate();\n\n        try {\n          Posts.submit(post);\n        } catch (error) {\n          // catch errors so they don't stop the loop\n          Telescope.log(error);\n        }\n      }\n\n      // Telescope.log('// Found ' + newItemsCount + ' new feed items');\n    }, function() {\n      Telescope.log('Failed to bind environment');\n    }, feedParser));\n  }\n};\n\nfetchFeeds = function() {\n  var contentBuffer;\n\n  Feeds.find().forEach(function(feed) {\n\n    // if feed doesn't specify a user, default to admin\n    var userId = !!feed.userId ? feed.userId : getFirstAdminUser()._id;\n    var feedCategories = feed.categories;\n    var feedId = feed._id;\n\n    try {\n      contentBuffer = HTTP.get(feed.url, {responseType: 'buffer'}).content;\n      feedHandler.handle(contentBuffer, userId, feedCategories, feedId);\n    } catch (error) {\n      console.log(error);\n      return true; // just go to next feed URL\n    }\n  });\n};\n\nMeteor.methods({\n  fetchFeeds: function () {\n    fetchFeeds();\n  },\n  testEntities: function (text) {\n    console.log(he.decode(text));\n  },\n  testToMarkdown: function (text) {\n    console.log(toMarkdown(text));\n  }\n});\n","SyncedCron.options = {\n  log: false,\n  collectionName: 'cronHistory',\n  utc: false, \n  collectionTTL: 172800\n}\n\nvar addJob = function () {\n  SyncedCron.add({\n    name: 'Post by RSS feed',\n    schedule: function(parser) {\n      return parser.text('every 30 minutes');\n    }, \n    job: function() {\n      if (Feeds.find().count()) {\n        fetchFeeds();\n      }\n    }\n  });\n}\n\nMeteor.startup(function () {\n  addJob();\n})\n","Meteor.publish('feeds', function() {\n  if(Users.is.adminById(this.userId)){\n    return Feeds.find();\n  }\n  return [];\n});\n","var _ = Package.underscore._,\n    package_name = \"project\",\n    namespace = \"project\";\n\nif (package_name != \"project\") {\n    namespace = TAPi18n.packages[package_name].namespace;\n}\nTAPi18n._enable({\"helper_name\":\"_\",\"supported_languages\":null,\"i18n_files_route\":\"/tap-i18n\",\"cdn_path\":null});\nTAPi18n.languages_names[\"en\"] = [\"English\",\"English\"];\n// integrate the fallback language translations \ntranslations = {};\ntranslations[namespace] = {\"feed_already_exists\":\"A feed with the same URL already exists.\",\"you_need_to_login_and_be_an_admin_to_add_a_new_feed\":\"You need to log in and be an admin to add a new feed.\",\"import_new_posts_from_feeds\":\"Import new posts from feeds.\"};\nTAPi18n._loadLangFileObject(\"en\", translations);\n"]}