{"version":3,"sources":["kestanous:herald/lib/$herald.js","kestanous:herald/lib/collection.js","kestanous:herald/lib/couriers.js","kestanous:herald/lib/runners.js","kestanous:herald/lib/users.js","kestanous:herald/lib/onsite.js","kestanous:herald/lib/helpers.js","kestanous:herald/server/createNotification.js","kestanous:herald/server/escalate.js","kestanous:herald/server/publish.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qE;AACA,U;AACA,gC;AACA,a;AACA,yD;AACA,sB;AACA,gC;AACA,oC;AACA,wB;AACA,yB;AACA,I;;AAEA,qB;AACA,mF;AACA,gF;AACA,I;AACA,0E;AACA,0E;AACA,4D;;;AAGA,Y;AACA,gB;AACA,oF;AACA,E;;AAEA,gF;AACA,2E;AACA,E;AACA,oE;AACA,E;AACA,8D;AACA,e;AACA,E;AACA,0F;AACA,oF;AACA,4E;AACA,uC;AACA,c;AACA,iD;AACA,uD;;AAEA,gG;AACA,+D;;AAEA,mB;AACA,qG;AACA,K;AACA,G;AACA,qC;;AAEA,8B;AACA,8B;AACA,G;;AAEA,iC;AACA,yC;AACA,+B;AACA,O;AACA,G;;AAEA,0F;AACA,E;;AAEA,6C;AACA,e;AACA,mB;AACA,a;AACA,E;;AAEA,4C;AACA,6B;AACA,+B;AACA,0B;AACA,K;AACA,a;AACA,E;;AAEA,mC;AACA,yB;AACA,sC;AACA,G;AACA,+B;AACA,+E;AACA,G;AACA,c;AACA,E;;AAEA,iE;AACA,2C;AACA,wC;AACA,4C;AACA,E;;AAEA,0C;AACA,4B;AACA,8B;AACA,4B;AACA,iC;AACA,wC;AACA,yB;AACA,G;AACA,wB;AACA,iC;AACA,C;;;;;;;;;;;;;;;;;;;ACxGA,4B;AACA,iD;AACA,6E;AACA,wC;AACA,6F;AACA,+D;AACA,kG;AACA,qF;AACA,oD;AACA,gD;AACA,qF;AACA,oC;AACA,wD;;AAEA,mF;AACA,U;;AAEA,2C;AACA,sD;AACA,S;AACA,Q;AACA,0B;AACA,K;AACA,K;;AAEA,sD;AACA,gF;AACA,6F;AACA,G;;AAEA,uE;AACA,8D;AACA,a;AACA,2B;AACA,oC;AACA,kE;AACA,mB;AACA,M;AACA,oC;AACA,kC;AACA,M;AACA,oC;AACA,kC;AACA,K;AACA,K;AACA,G;;;;;;;;;;;;;;;;;;;AC7CA,6C;AACA,qB;AACA,yB;;AAEA,+B;AACA,qE;AACA,E;AACA,yC;AACA,kC;AACA,K;;AAEA,yF;AACA,wB;AACA,iC;;AAEA,sC;AACA,sB;AACA,qF;;AAEA,qC;AACA,gD;AACA,gF;;AAEA,iE;AACA,O;AACA,G;AACA,kB;AACA,gC;AACA,wC;;AAEA,+C;AACA,8D;AACA,E;;;;;;;;;;;;;;;;;;;AChCA,sC;AACA,4F;AACA,sF;AACA,8F;AACA,kG;AACA,+D;AACA,0E;;AAEA,uE;;AAEA,kC;AACA,2B;AACA,sD;AACA,2B;AACA,sD;AACA,K;;AAEA,qD;AACA,C;;;AAGA,uB;AACA,mC;AACA,4B;AACA,E;;AAEA,oC;AACA,6B;AACA,E;;AAEA,yC;AACA,0C;AACA,E;;AAEA,kD;AACA,yD;AACA,E;;;AAGA,6D;AACA,2B;AACA,e;AACA,sF;AACA,Y;AACA,gB;AACA,kB;AACA,Y;AACA,iB;AACA,kB;AACA,4F;AACA,2E;AACA,sF;AACA,yF;AACA,sE;AACA,W;AACA,Q;AACA,0C;AACA,iE;AACA,6E;AACA,O;AACA,Y;AACA,oB;AACA,kB;AACA,qF;AACA,wF;AACA,6C;AACA,4E;AACA,+C;AACA,gF;AACA,sE;AACA,4E;AACA,O;AACA,Y;AACA,Y;AACA,oG;AACA,G;AACA,a;AACA,C;;AAEA,gB;AACA,iE;AACA,iE;AACA,2D;;AAEA,sG;AACA,gD;AACA,sG;AACA,I;AACA,uF;AACA,oD;AACA,8E;;AAEA,uF;AACA,wB;AACA,0C;AACA,wE;AACA,kB;AACA,kE;AACA,6D;AACA,4F;AACA,W;AACA,Y;AACA,0C;AACA,4C;AACA,kB;AACA,2D;AACA,W;AACA,S;AACA,K;AACA,K;AACA,iE;AACA,+F;AACA,iE;AACA,sG;AACA,6B;AACA,qC;AACA,kE;AACA,gB;AACA,K;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACxHA,0E;AACA,qH;;AAEA,8B;AACA,iE;AACA,mE;AACA,sF;;AAEA,wG;AACA,qD;AACA,2H;AACA,E;AACA,0C;AACA,wF;;AAEA,Y;AACA,sB;AACA,6F;AACA,G;AACA,oC;AACA,2H;AACA,G;;AAEA,iC;AACA,iD;AACA,6F;AACA,sG;AACA,6F;AACA,uB;;AAEA,8E;AACA,2E;AACA,4D;;AAEA,qF;AACA,wD;AACA,C;;AAEA,yC;AACA,6D;AACA,0F;AACA,4C;AACA,oF;AACA,8C;AACA,sF;AACA,E;AACA,0C;AACA,uF;;AAEA,4D;AACA,E;AACA,W;AACA,yE;;AAEA,oC;AACA,wE;;AAEA,6C;AACA,6B;AACA,K;AACA,a;AACA,kD;AACA,gC;AACA,K;;AAEA,yB;AACA,0C;AACA,C;;AAEA,8C;AACA,W;AACA,oB;AACA,yB;AACA,kB;AACA,M;AACA,I;AACA,G;;AAEA,0D;AACA,W;AACA,oB;AACA,gB;AACA,yD;AACA,M;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACrFA,c;AACA,iB;AACA,mB;AACA,E;AACA,8C;AACA,8B;AACA,yB;;;;;;;;;;;;;;;;;;;ACNA,iD;AACA,qD;AACA,mD;AACA,8C;AACA,c;AACA,G;;AAEA,2B;AACA,sF;AACA,G;;AAEA,qE;AACA,4B;AACA,sF;AACA,G;;AAEA,0B;AACA,4B;AACA,0B;AACA,+B;;AAEA,a;AACA,gD;;AAEA,yB;AACA,2B;AACA,iE;AACA,G;;AAEA,kB;AACA,gD;AACA,sF;AACA,G;;AAEA,iB;AACA,uD;AACA,oF;AACA,G;;AAEA,+C;AACA,e;AACA,iD;AACA,G;AACA,gB;AACA,+B;AACA,G;;AAEA,gD;AACA,E;;AAEA,uC;AACA,gB;AACA,oC;AACA,uD;AACA,0B;AACA,wB;AACA,G;AACA,G;;;;;;;;;;;;;;;;;;;ACzDA,6D;AACA,wD;AACA,mF;AACA,wB;;AAEA,mD;AACA,iB;AACA,kE;AACA,G;;AAEA,kC;AACA,+C;AACA,uF;AACA,E;AACA,uE;;AAEA,sC;AACA,O;AACA,iD;AACA,8C;AACA,oC;AACA,qD;AACA,kD;AACA,+D;AACA,0F;AACA,wF;;AAEA,wB;AACA,4B;AACA,uB;AACA,8B;AACA,wB;AACA,kB;AACA,uB;AACA,sB;AACA,e;AACA,M;;AAEA,yD;AACA,qD;AACA,oD;AACA,iF;AACA,Q;AACA,uD;AACA,kF;AACA,O;;AAEA,2C;AACA,gE;;AAEA,sF;AACA,yB;AACA,wC;AACA,4C;AACA,K;;AAEA,0B;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC1DA,0C;AACA,4B;AACA,4C;AACA,wD;AACA,kC;AACA,6G;AACA,G;AACA,G;;;AAGA,mD;AACA,wE;;AAEA,oF;AACA,iF;AACA,8G;AACA,oC;AACA,iG;AACA,sC;AACA,Y;AACA,8D;AACA,K;AACA,K;;AAEA,6E;AACA,C;;AAEA,gB;AACA,K;AACA,mE;AACA,I;AACA,mC;AACA,2B;AACA,K;AACA,qD;AACA,S;AACA,8C;AACA,iB;AACA,kE;AACA,K;AACA,G;AACA,G;;;AAGA,qD;AACA,+D;AACA,4D;AACA,sE;AACA,4G;AACA,uE;;AAEA,uD;AACA,4C;;AAEA,kE;AACA,8E;;AAEA,yD;AACA,uD;AACA,uD;;AAEA,gC;AACA,sE;AACA,iG;AACA,0D;AACA,G;;AAEA,Y;AACA,0E;AACA,oF;AACA,U;AACA,wE;AACA,G;AACA,E;AACA,+D;AACA,E;;;;;;;;;;;;;;;;;;;AC3EA,2D;AACA,6C;AACA,gE;AACA,4E;AACA,K;AACA,qE;AACA,G","file":"/packages/kestanous:herald.js","sourcesContent":["//This is our Global Object. $herald.js will be the first file loaded\nHerald = {\n  //Notification global settings\n  settings: {\n    overrides: {}, //disable functionality for all users.\n    queueTimer: 60000,\n    userPreferenceDefault: true,\n    collectionName: 'notifications',\n    useIronRouter: true,\n    expireAfterSeconds: 0\n  },\n\n  //media and runners\n  _media: function () { //supported media, extension packages should push new kinds\n    return _.union(_.keys(Herald._serverRunners), _.keys(Herald._clientRunners))\n  },\n  _serverRunners: {}, //extension packages load their code here on servers\n  _clientRunners: {}, //extension packages load their code here on clients\n  _runnerCheckers: {}, //test if courier media data is valid\n\n\n  //couriers\n  _couriers: {},\n  _extentionParams: [] //UNDOCUMENTED: allow for more top level params on EventTypes\n};\n\n// Package users can define a predefined message from the notification instance.\n// It requires the user pass a options.message function, string, or object.\n//\n// If its a function it will be run with the from the instance scope\n//\n// If its a string it will return a template with the instance\n// as its data.\n//\n// If its an object it will run any number of templates or functions based on the optional\n// string argument given at the time of call. If no string is passed it will default\n// to 'default'. From there it acts the same as ether of the above patterns.\nHerald._message = function (template) {\n  var message;\n  var courier = Herald._getCourier(this.courier);\n  var messageFormat = courier && courier.messageFormat;\n\n  if (_.isObject(messageFormat) && !_.isFunction(messageFormat) && !_.isString(messageFormat)) {\n    message = messageFormat[template] || messageFormat.default;\n\n    if (!message) {\n      throw new Error('Herald: No default message defined for \"' + this.courier + '\" notifications');\n    }\n  }\n  message = message || messageFormat;\n\n  if (_.isFunction(message)) {\n    return message.call(this);\n  }\n\n  else if (_.isString(message)) {\n    return Blaze.With(this, function () {\n      return Template[message];\n    });\n  }\n\n  throw new Error('Herald: message not defined for \"' + this.courier + '\" notifications');\n};\n\nHerald._setProperty = function (key, value) {\n  var obj = {};\n  obj[key] = value;\n  return obj;\n};\n\nHerald._getProperty = function (obj, keys) {\n  var keys = keys.split('.');\n  _.each(keys, function (key) {\n    obj = obj && obj[key];\n  });\n  return obj;\n};\n\nHerald._getUser = function (user) {\n  if (_.isString(user)) {\n    user = Meteor.users.findOne(user);\n  }\n  else if (!_.isObject(user)) {\n    user = Meteor.isClient ? Meteor.user() : Meteor.users.findOne(this.userId);\n  }\n  return user;\n};\n\n// retrieves from Herald._couriers by default, otherwise from obj\nHerald._getCourier = function (keys, obj) {\n  var courier = obj || Herald._couriers;\n  return Herald._getProperty(courier, keys);\n};\n\nHerald._setCourier = function (key, val) {\n  var keys = key.split('.');\n  var orig = Herald._couriers;\n  var len = keys.length - 1;\n  for (var i = 0; i < len; i++) {\n    orig[keys[i]] = orig[keys[i]] || {};\n    orig = orig[keys[i]];\n  }\n  orig[keys[len]] = val;\n  return Herald._getCourier(key);\n}\n","Meteor.startup(function () {\n  //The collection and any instance functionality\n  Herald.collection = new Meteor.Collection(Herald.settings.collectionName, {\n    transform: function (notification) {\n      if (notification.courier) { //courier may not be available if fields filter was called.\n        var courier = Herald._getCourier(notification.courier);\n        //This is the basic message you want to output. Use in the app or as an email subject line\n        // it is optional and is set up with createNotification from the server code.\n        notification.message = function (template) {\n          if (template && !_.isString(template))\n            throw new Error('Herald: message argument must be undefined or a string')\n          if (courier.messageFormat)\n            return Herald._message.call(this, template);\n\n          throw new Error('Herald: no message defined for \"' + this.courier + '\"');\n        };\n\n        if (courier && courier.transform) {\n          _.defaults(notification, courier.transform);\n        }\n      };\n      return notification;\n    }\n  });\n\n  var expireTime = Herald.settings.expireAfterSeconds;\n  if (Meteor.isServer && expireTime && Herald.collection.find().count() === 0) {\n    Herald.collection._ensureIndex({ 'timestamp': 1 }, { 'expireAfterSeconds': expireTime });\n  }\n\n  //Minimum requirement for notifications to work while still providing\n  //basic security. For added limitations use `Herald.deny` in\n  //your app.\n  Herald.collection.allow({\n    insert: function (userId, doc) {\n      // new notifications can only be created via a Meteor method\n      return false;\n    },\n    update: function (userId, doc) {\n      return userId == doc.userId;\n    },\n    remove: function (userId, doc) {\n      return userId == doc.userId;\n    }\n  });\n});\n","Herald.addCourier = function (key, options) {\n  check(key, String);\n  check(options, Object);\n\n  if (Herald._getCourier(key)) \n    throw new Error('Herald: courier \"' + key + '\"\" already exists');\n  \n  var courier = Herald._setCourier(key, {\n    messageFormat: options.message\n  });\n\n  //media is required but should only throw exceptions on the server, where it is needed.\n  if (Meteor.isServer) {\n    check(options.media, Object);\n\n    var media = _.keys(options.media);\n    if (!media.length)\n      throw new Error('Herald: courier \"' + key + '\" must have at least one medium');\n\n    media.forEach(function (medium) {\n      if (!_.contains(Herald._media(), medium)) \n        throw new Error('Herald: medium \"' + medium + '\" is not a known media');\n\n      Herald._runnerCheckers[medium].call(options.media[medium]);\n    });\n  }\n  //define on both\n  courier.media = options.media;\n  courier.transform = options.transform;\n\n  //white-listed params from extension packages\n  _.extend(courier, _.pick(options, Herald._extentionParams));\n};\n","Herald.addRunner = function (object) {\n  if (!_.isObject(object)) throw new Error('Herald: Runner must have an `object` argument');\n  if (! _.isString(object.name)) throw new Error('Herald: Runner must medium `name`');\n  if (!_.isFunction(object.run)) throw new Error('Herald: Runner must have a `run` function');\n  if (!_.isFunction(object.check)) throw new Error('Herald: Runner must have a `check` function');\n  if (! (_.isArray(object.where) || _.isString(object.where))) \n    throw new Error('Herald: Runner `where` must be a valid environment');\n\n  var where = _.isString(object.where) ? [object.where] : object.where;\n\n  _.each(where, function (where) {\n    if (where === 'server')\n      Herald._serverRunners[object.name] = object.run;\n    if (where === 'client')\n      Herald._clientRunners[object.name] = object.run;\n  });\n\n  Herald._runnerCheckers[object.name] = object.check;\n}\n\n\nonRun = function () {};\nonRun.prototype.run = function () {\n  return { command: 'run' };\n};\n\nonRun.prototype.stop = function () {\n  return { command: 'stop' };\n};\n\nonRun.prototype.delay = function (time) {\n  return { command: 'delay', time: time };\n};\n\nonRun.prototype.transfer = function (name, time) {\n  return { command: 'transfer', name: name, time: time };\n};\n\n\nonRunResolve = function (notification, medium, result, run) {\n  switch (result.command) {\n    case 'run':\n      //run true, but invalidation could have been triggered elsewhere so don't change\n      break;\n    case 'stop':\n      run = false;\n      break;\n    case 'delay':\n      run = false;\n      if (Herald._serverRunners[medium]) { //will only be called on server, no method needed\n        var query = Herald._setProperty('media.' + medium + '.send', true);\n        var command = 'Herald.escalate(\"' + notification._id + '\", \"' + medium + '\")';\n        Herald.collection.update(notificationId, { $set: query }, function (err, count) {\n          Queue.add({ command: command, execute_after: result.time });\n        });\n      } \n      if (Herald._clientRunners[medium]) {\n        var delay = result.time.getTime() - new Date().getTime();\n        Meteor.call('HeraldUpdateAndDelay', notification._id, medium, delay);\n      }\n      break;\n    case 'transfer':\n      run = false;\n      if (!Herald._clientRunners[result.name] && !Herald._serverRunners[result.name])\n        throw new Error('Herald: '+ medium +' transfer call - no medium '+ result.name);\n      if (Herald._serverRunners[result.name])\n        Meteor.call('HeraldTransferServerMedium', notification._id, result);\n      if (Herald._clientRunners[result.name]) {\n        var delay = result.time && result.time.getTime() - new Date().getTime();\n        var query = Herald._setProperty('media.' + result.name, true);\n        Meteor.call('HeraldUpdateAndDelay', notification._id, query, delay);\n      }\n      break;\n    default:\n      throw new Error('Herald:' + medium + ' onRun returned the unknown command ' + result.command);\n  }\n  return run;\n}\n\nMeteor.methods({\n  HeraldTransferServerMedium: function (notificationId, result) {\n    var notification = Herald.collection.findOne(notificationId);\n    var courier = Herald._getCourier(notification.courier);\n\n    if (this.userId !== notification.userId) throw new Meteor.Error(550, 'Herald: permission denied');\n    if (courier && !courier.media[result.name]) \n      throw new Error('Herald: ' + notification.courier + ' transfer call - no medium '+ result.name);\n    \n    var command = 'Herald.escalate(\"' + notification._id + '\", \"' + result.name + '\")';\n    if (Meteor.isServer) {//simulation causes errors\n      var query = Herald._setProperty('media.' + result.name + '.send', true);\n\n      Herald.collection.update(notificationId, { $set: query }, function (err, count) {\n        if (result.time)\n          if (Package['artwells:queue']) {\n            Queue.add({ command: command, execute_after: result.time });\n          } else {\n            //TODO: how are we going to do delays without a queue?\n            //Herald.escalate(notification._id, result.name);\n            throw new Meteor.error('Herald: delay is not available without artwells:queue');\n          }\n        else\n          if (Package['artwells:queue']) {\n            Queue.add({ command: command });\n          } else {\n            Herald.escalate(notification._id, result.name);\n          }\n      });\n    }\n  }, \n  HeraldUpdateAndDelay: function (notificationId, query, delay) {\n    if (!delay || delay < 1000) delay = 1000; //give at least one second for the dust to settle\n    var notification = Herald.collection.findOne(notificationId);\n    if (this.userId !== notification.userId) throw new Meteor.Error(550, 'Herald: permission denied');\n    if (!this.isSimulation) {\n      Meteor.setTimeout(function () {\n        Herald.collection.update(notificationId, { $set: query });\n      }, delay);\n    }\n  }\n});\n","//userPreference - can be easily overloaded without loss of functionality.\nHerald.userPreference = function (user, medium, courier) { return Herald.getUserPreference(user, medium, courier); };\n\n// set user medium preference \nHerald.setUserPreference = function (user, preference, courier) {\n  if (courier && !Herald._getCourier(courier)) //optional and check\n    throw new Error('Herald - getUserPreference: courier \"' + courier + '\" not found')\n\n  if (!_.isObject(preference)) throw new Error('Herald - getUserPreference: no media preference given');\n  var badKeys = _.omit(preference, Herald._media()); \n  if (!_.isEmpty(badKeys)) throw new Error('Herald - getUserPreference: \"' + _.toArray(badKeys) + '\" are not valid media');\n  \n  user = Herald._getUser.call(this, user);\n  if (!user || !user._id) throw new Error('Herald - setUserPreference: user not found');\n\n  //not set \n  if (!user.profile) {\n    return Meteor.users.update(user._id, { $set: { profile: newProfileMedia(preference) } });\n  }\n  if (!user.profile.notifications) {\n    return Meteor.users.update(user._id, { $set: { 'profile.notifications': newProfileMedia(preference).notifications } });\n  }\n\n  if (!courier) { // generic only\n    var media = user.profile.notifications.media;\n    // if media preference is set, merge medium preferences. otherwise, create new preference\n    var media = media ? _.extend(media, preference) : newProfileMedia(preference).notifications.media;\n    return Meteor.users.update(user._id, { $set: { 'profile.notifications.media': media } });\n  } // generic only end\n\n  var pref = Herald._getCourier(courier, user.profile.notifications.couriers);\n  // if courier is set, merge courier preferences. otherwise use preference\n  var pref = pref ? _.extend(pref, preference) : preference;\n\n  var query = Herald._setProperty('profile.notifications.couriers.' + courier, pref);\n  return Meteor.users.update(user._id, { $set: query });\n}\n\n// get user [medium [courier]] preference\nHerald.getUserPreference = function (user, medium, courier) {\n  if (!_.isString(medium)) throw new Error('Herald - getUserPreference: no medium given');\n  if (!_.contains(Herald._media(), medium)) \n    throw new Error('Herald - getUserPreference: medium \"' + medium + '\" not found')\n  if (courier && !Herald._getCourier(courier))\n    throw new Error('Herald - getUserPreference: courier \"' + courier + '\" not found')\n  \n  user = Herald._getUser.call(this, user);\n  if (!user || !user._id) throw new Error('Herald - getUserPreference: user not found')\n\n  var defaultOutput = Herald.settings.userPreferenceDefault;\n  \n  //not set\n  if (!user.profile || !user.profile.notifications) return defaultOutput;\n\n  return (function (pref, courier) {\n    var courier = courier && Herald._getCourier(courier, pref.couriers);\n\n    if (courier && _.has(courier, medium)) { \n      return courier[medium];\n    }\n    //general\n    if (pref.media && _.has(pref.media, medium)) {\n      return pref.media[medium];\n    }\n\n    return defaultOutput;\n  })(user.profile.notifications, courier);\n}\n\nvar newProfileMedia = function (preferences) {\n  return { \n    notifications: {\n      media: preferences,\n      couriers: {}\n    } \n  };\n}; \n\nvar newProfileCouriers = function (courier, preferences) {\n  return { \n    notifications: {\n      media: {},\n      couriers: Herald._setProperty(courier, preferences)\n    } \n  };\n}; \n","var runner = {\n  name: 'onsite',\n  where: ['client']\n};\nrunner.run = function (notification, user) {};\nrunner.check = function () {};\nHerald.addRunner(runner);\n","//get notifications by user, [courier, [[medium]]\nHerald.getNotifications = function (query, options) {\n  // break function if not finished with logging in\n  if (Meteor.isClient && Meteor.loggingIn()) {\n    return [];\n  }\n\n  if (!_.isObject(query)) {\n    throw new Meteor.Error('Herald getNotifications must contain Mongo filter query');\n  }\n\n  var badKeys = _.omit(query, ['user', 'courier', 'medium', 'read']);\n  if (!_.isEmpty(badKeys)) {\n    throw new Error('Herald - getNotifications: unknown key(s) ' + _.toArray(badKeys))\n  }\n\n  var userId = query.user,\n    courier = query.courier,\n    medium = query.medium,\n    read = query.read || false;\n\n  // get user\n  var user = Herald._getUser.call(this, userId);\n\n  // check if user exists\n  if (!user || !user._id) {\n    throw new Error('Herald - getNotifications: user not found');\n  }\n\n  // check courier\n  if (courier && !Herald._getCourier(courier)) {\n    throw new Error('Herald - getNotifications: courier \"' + courier + '\" not found');\n  }\n\n  // check medium\n  if (medium && !_.contains(Herald._media(), medium)) {\n    throw new Error('Herald - getNotifications: medium \"' + medium + '\" not found');\n  }\n\n  var query = { userId: user._id, read: read };\n  if (medium) {\n    query['media.' + medium] = { $exists: true };\n  }\n  if (courier) {\n    query['courier'] = courier;\n  }\n\n  return Herald.collection.find(query, options);\n};\n\n//literally mark-All-As-Read, cheers :)\nMeteor.methods({\n  heraldMarkAllAsRead: function () {\n    Herald.collection.update({ userId: this.userId }, {\n      $set: { read: true }\n    }, { multi: true });\n  }\n});\n","//You can insert manually but this should save you some work.\nHerald.createNotification = function (userIds, params) {\n  check(userIds, Match.OneOf([String], String)); //TODO: better Collection ID check\n  check(params, Object);\n\n  var courier = Herald._getCourier(params.courier);\n  if (!courier) {\n    throw new Error('Notification: courier type does not exists');\n  }\n\n  // always assume multiple users.\n  if (_.isString(userIds)) userIds = [userIds];\n  var users = Meteor.users.find({ _id: { $in: userIds } }, { fields: { profile: 1 } });\n  \n  users.forEach(function (user) { //create a notification for each user\n\n    //When creating a new notification\n    // \n    // timestamp - you should timestamp every doc\n    // userId - there must be a user to notify\n    // courier - this is the courier\n    // data - in database metadata, consider renaming\n    // read - default false, consider auto-delete?\n    // escalated - track if higher level notifications have run\n    // url - allow of iron:router magic. set read to true if visited (see routeSeenByUser)\n    // media - a list of all the media the notification can be sent on but has not been.\n\n    var notification = {\n      timestamp: new Date(),\n      userId: user._id,\n      courier: params.courier,\n      data: params.data,\n      read: false,\n      escalated: false,\n      url: params.url,\n      media: {}\n    };\n\n    //check if this notification should be sent to medium\n    _.each(_.keys(courier.media), function (medium) {\n      var fallback = courier.media[medium].fallback;\n      var preference = Herald.userPreference(user, medium, notification.courier);\n        \n      // run if not a fallback and preference allows it\n      notification.media[medium] = { send: !fallback && preference, sent: false };\n    });\n\n    //create notification and return its id\n    var notificationId = Herald.collection.insert(notification);\n\n    //if no notificationId then insert failed anD PANIC, STOP, DON'T ACUTALLY DO THIS!\n    if (notificationId) {\n      notification._id = notificationId;\n      Herald.SetupEscalations(notification);\n    }\n\n    return notificationId;\n  });\n};\n","//allow package users to delay escalations\nMeteor.startup(function () {\n  //if no pattern is defined then skip this.\n  // if (!Herald.settings.delayEscalation) return false;\n  if (Package['artwells:queue']) {\n    Meteor.setInterval(function ( ){ Queue.run() }, Herald.settings.queueTimer); // by default, once a minute\n  }\n});\n\n\nHerald.SetupEscalations = function (notification) {\n  if (notification.escalated) return false; //don't resend notifications\n\n  _.each(_.keys(Herald._getCourier(notification.courier).media), function (medium) {\n    if (!_.contains(_.keys(Herald._serverRunners), medium)) return; //Server only\n    if (!notification.media[medium].send || notification.media[medium].sent) return; //already sent/don't send\n    if (Package['artwells:queue']) {\n      var command = 'Meteor.call(\"heraldEscalate\",\"' + notification._id + '\", \"' + medium + '\")';\n      Queue.add({ command: command });\n    } else {\n      Meteor.call(\"heraldEscalate\", notification._id, medium);\n    }\n  });\n\n  Herald.collection.update(notification._id, { $set: { escalated: true } } );\n}\n\nMeteor.methods({\n  /**\n   * Server method to call Herald.escalate out of the queue package\n   *\n   * @param {string} notificationId\n   * @param {string} medium\n   */\n  heraldEscalate: function (notificationId, medium) {\n    try {\n      Herald.escalate(notificationId, medium);\n    } catch (e) {\n      throw new Meteor.Error(\"Can't start Herald.escalate: \" + e);\n    }\n  }\n});\n\n\nHerald.escalate = function (notificationId, medium) {\n  var notification = Herald.collection.findOne(notificationId);\n  if (!notification) return; //notification has been removed\n  if (notification.read) return; //don't escalate a read notification!\n  if (!notification.media[medium].send || notification.media[medium].sent) return; //already sent/don't send\n  if (Herald.settings.overrides[medium]) return; //disabled by override\n\n  var user = Meteor.users.findOne(notification.userId);\n  if (!user) return; //user has been removed\n\n  var run = true; //does the user want you to send on this medium?\n  if (!Herald.userPreference(user, medium, notification.courier)) run = false;\n\n  var courier = Herald._getCourier(notification.courier);\n  var courierMedium = courier && courier.media[medium];\n  var thisOnRun = courierMedium && courierMedium.onRun;\n\n  if (_.isFunction(thisOnRun)) {\n    var result = thisOnRun.call(new onRun(), notification, user, run);\n    if (!result.command) throw new Error('Herald:' + medium + ' onRun did not return a command');\n    run = onRunResolve(notification, medium, result, run);\n  }\n\n  if (run) {\n    Herald._serverRunners[medium].call(courierMedium, notification, user);\n    var query = Herald._setProperty('media.' + medium, { send: false, sent: true });\n  } else {\n    var query = Herald._setProperty('media.' + medium + '.send', false);\n  }\n  \n  Herald.collection.update(notification._id, { $set: query } );\n};\n","// only publish notifications belonging to the current user\nMeteor.publish('notifications', function () {\n  var media = _.keys(Herald._clientRunners).map(function (key) {\n    return Herald._setProperty('media.' + key, { send: true, sent: false });\n  });\n  return Herald.collection.find({ userId: this.userId, $or: media });\n});\n"]}