{"version":3,"sources":["meteorhacks:meteorx/lib/livedata.js","meteorhacks:meteorx/lib/mongo-livedata.js","meteorhacks:meteorx/lib/server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,sC;AACA,yB;AACA,4E;AACA,+E;AACA,sE;;AAEA,6D;AACA,8D;;AAEA,6D;AACA,sE;;AAEA,6C;AACA,e;AACA,qE;AACA,sD;AACA,e;AACA,uE;AACA,K;AACA,8D;AACA,8D;;AAEA,gC;AACA,6D;AACA,sE;;AAEA,iD;AACA,U;AACA,qD;AACA,G;AACA,E;;AAEA,iD;AACA,0B;AACA,qD;AACA,6C;;AAEA,qE;AACA,+C;AACA,oD;;AAEA,e;AACA,mC;AACA,C;;AAEA,0D;AACA,iD;AACA,6D;;AAEA,oB;AACA,oD;AACA,yE;AACA,C;;;;;;;;;;;;;;;;;;ACpDA,2C;AACA,qF;AACA,0D;AACA,yE;AACA,iB;;AAEA,+F;AACA,2B;AACA,6C;AACA,qC;AACA,uC;AACA,qC;AACA,C;;AAEA,6C;AACA,iD;AACA,8C;AACA,yE;AACA,oD;AACA,G;AACA,C;;AAEA,+C;AACA,+D;AACA,0C;AACA,+C;AACA,0E;AACA,sD;AACA,G;AACA,C;;AAEA,6C;AACA,mD;AACA,mB;AACA,oD;AACA,G;AACA,C;;AAEA,qC;AACA,4C;AACA,iD;AACA,sC;AACA,G;AACA,C;;AAEA,kC;AACA,mE;AACA,iB;AACA,8B;AACA,C;;;;;;;;;;;;;;;;;;;ACjDA,+B;;AAEA,a;AACA,6B;AACA,uB;;AAEA,gC;AACA,iC;;AAEA,gC;AACA,E;;AAEA,2C;AACA,wB;;AAEA,+D;AACA,4D;AACA,6C;AACA,2B;AACA,yB;AACA,iC;AACA,kD;AACA,W;AACA,O;AACA,0B;AACA,W;AACA,G","file":"/packages/meteorhacks:meteorx.js","sourcesContent":["exposeLivedata = function(namespace) {\n  //instrumenting session\n  var fakeSocket = {send: function() {}, close: function() {}, headers: []};\n  var ddpConnectMessage = {msg: 'connect', version: 'pre1', support: ['pre1']};\n  Meteor.default_server._handleConnect(fakeSocket, ddpConnectMessage);\n\n  if(fakeSocket._meteorSession) { //for newer meteor versions\n    namespace.Session = fakeSocket._meteorSession.constructor;\n\n    exposeSubscription(fakeSocket._meteorSession, namespace);\n    exposeSessionCollectionView(fakeSocket._meteorSession, namespace);\n\n    if(Meteor.default_server._closeSession) {\n      //0.7.x +\n      Meteor.default_server._closeSession(fakeSocket._meteorSession);\n    } else if(Meteor.default_server._destroySession) {\n      //0.6.6.x\n      Meteor.default_server._destroySession(fakeSocket._meteorSession);\n    }\n  } else if(fakeSocket.meteor_session) { //support for 0.6.5.x\n    namespace.Session = fakeSocket.meteor_session.constructor;\n\n    //instrumenting subscription\n    exposeSubscription(fakeSocket.meteor_session, namespace);\n    exposeSessionCollectionView(fakeSocket._meteorSession, namespace);\n\n    fakeSocket.meteor_session.detach(fakeSocket);\n  } else {\n    console.error('expose: session exposing failed');\n  }\n};\n\nfunction exposeSubscription(session, namespace) {\n  var subId = Random.id();\n  var publicationHandler = function() {this.ready()};\n  var pubName = '__dummy_pub_' + Random.id();\n\n  session._startSubscription(publicationHandler, subId, [], pubName);\n  var subscription = session._namedSubs[subId];\n  namespace.Subscription = subscription.constructor;\n\n  //cleaning up\n  session._stopSubscription(subId);\n}\n\nfunction exposeSessionCollectionView(session, namespace) {\n  var documentView = session.getCollectionView();\n  namespace.SessionCollectionView = documentView.constructor;\n\n  var id = 'the-id';\n  documentView.added('sample-handle', id, {aa: 10});\n  namespace.SessionDocumentView = documentView.documents[id].constructor;\n}","exposeMongoLivedata = function(namespace) {\n  var MongoColl = (typeof Mongo != \"undefined\")? Mongo.Collection: Meteor.Collection;\n  var coll = new MongoColl('__dummy_coll_' + Random.id());\n  //we need wait until db get connected with meteor, .findOne() does that\n  coll.findOne();\n\n  namespace.MongoConnection = MongoInternals.defaultRemoteCollectionDriver().mongo.constructor;\n  var cursor = coll.find();\n  namespace.MongoCursor = cursor.constructor;\n  exposeOplogDriver(namespace, coll);\n  exposePollingDriver(namespace, coll);\n  exposeMultiplexer(namespace, coll);\n}\n\nfunction exposeOplogDriver(namespace, coll) {\n  var driver = _getObserverDriver(coll.find({}));\n  // verify observer driver is an oplog driver\n  if(driver && typeof driver.constructor.cursorSupported == 'function') {\n    namespace.MongoOplogDriver = driver.constructor;\n  }\n}\n\nfunction exposePollingDriver(namespace, coll) {\n  var cursor = coll.find({}, {limit: 20, _disableOplog: true});\n  var driver = _getObserverDriver(cursor);\n  // verify observer driver is a polling driver\n  if(driver && typeof driver.constructor.cursorSupported == 'undefined') {\n    namespace.MongoPollingDriver = driver.constructor;\n  }\n}\n\nfunction exposeMultiplexer(namespace, coll) {\n  var multiplexer = _getMultiplexer(coll.find({}));\n  if(multiplexer) {\n    namespace.Multiplexer = multiplexer.constructor;\n  }\n}\n\nfunction _getObserverDriver(cursor) {\n  var multiplexer = _getMultiplexer(cursor);\n  if(multiplexer && multiplexer._observeDriver) {\n    return multiplexer._observeDriver;\n  }\n}\n\nfunction _getMultiplexer(cursor) {\n  var handler = cursor.observeChanges({added: Function.prototype});\n  handler.stop();\n  return handler._multiplexer;\n}\n","Fibers = Npm.require('fibers');\n\nMeteorX = {};\nMeteorX._readyCallbacks = [];\nMeteorX._ready = false;\n\nMeteorX.onReady = function(cb) {\n  if(MeteorX._ready) return cb();\n\n  this._readyCallbacks.push(cb);\n};\n\nMeteorX.Server = Meteor.server.constructor;\nexposeLivedata(MeteorX);\n\n// exposeMongoLivedata needs to wait until the DB is connecting\n// But we don't need to wait other parts of the app for that\n// That's why we've Meteor.onReady() callback\nMeteor.startup(function() {\n  new Fibers(function() {\n    exposeMongoLivedata(MeteorX);\n    MeteorX._readyCallbacks.forEach(function(fn) {\n      fn();\n    });\n    MeteorX._ready = true;\n  }).run();\n});\n"]}