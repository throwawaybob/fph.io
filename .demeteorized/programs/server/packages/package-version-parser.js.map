{"version":3,"sources":["package-version-parser/semver410.js","package-version-parser/package-version-parser.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,W;AACA,iE;AACA,uB;AACA,+C;AACA,+D;AACA,iE;AACA,gE;AACA,6B;AACA,mB;AACA,Y;;AAEA,oD;AACA,6D;AACA,oC;;AAEA,qE;AACA,sB;AACA,8C;AACA,8B;AACA,yC;AACA,2D;AACA,kC;AACA,oE;AACA,uC;AACA,iD;AACA,kB;AACA,gB;AACA,oC;;AAEA,sE;AACA,oD;AACA,sC;;AAEA,sC;AACA,yB;AACA,2B;AACA,U;;AAEA,gE;AACA,kD;;AAEA,wB;AACA,qE;;AAEA,4B;AACA,uC;AACA,iC;AACA,uC;;;AAGA,4B;AACA,wE;AACA,oC;;AAEA,+B;AACA,yD;;;AAGA,kB;AACA,2C;;AAEA,sB;AACA,0D;AACA,0D;AACA,sD;;AAEA,2B;AACA,oE;AACA,oE;AACA,gE;;AAEA,oC;AACA,qD;;AAEA,+B;AACA,4D;AACA,kE;;AAEA,oC;AACA,sE;AACA,uE;;;AAGA,yB;AACA,oE;AACA,e;;AAEA,qB;AACA,uD;AACA,gE;;AAEA,0B;AACA,kE;AACA,0E;;AAEA,+B;AACA,kD;;AAEA,0B;AACA,uC;;AAEA,oB;AACA,qE;AACA,e;;AAEA,gB;AACA,+C;AACA,sD;;;AAGA,yB;AACA,mE;AACA,kB;;AAEA,sE;AACA,wE;AACA,iE;AACA,c;;AAEA,e;AACA,yC;AACA,uC;AACA,iC;;AAEA,kC;;AAEA,sE;AACA,oE;AACA,8B;AACA,qD;AACA,6C;AACA,kC;;AAEA,gB;AACA,oC;;AAEA,e;AACA,2B;;AAEA,mC;AACA,qE;AACA,4C;AACA,gC;AACA,sE;AACA,2B;AACA,4D;;AAEA,sB;AACA,8D;AACA,4D;AACA,4D;AACA,mD;AACA,qC;AACA,0B;;AAEA,2B;AACA,wE;AACA,sE;AACA,sE;AACA,6D;AACA,0C;AACA,+B;;AAEA,iB;AACA,gE;AACA,sB;AACA,0E;;AAEA,gB;AACA,6C;AACA,oB;AACA,2B;;AAEA,oB;AACA,oD;AACA,gD;AACA,6B;;AAEA,gB;AACA,2D;AACA,qB;AACA,qE;;AAEA,gB;AACA,sD;AACA,oB;AACA,2B;;AAEA,oB;AACA,oD;AACA,gD;AACA,6B;;AAEA,gB;AACA,2D;AACA,qB;AACA,qE;;AAEA,gE;AACA,0B;AACA,wE;AACA,qB;AACA,kE;;;AAGA,uE;AACA,8C;AACA,yB;AACA,4C;AACA,0E;;AAEA,kC;AACA,0D;AACA,qC;;;AAGA,iC;AACA,6D;AACA,6D;AACA,S;AACA,sB;AACA,sD;AACA,gC;AACA,iD;AACA,2B;;AAEA,2B;AACA,gE;AACA,qC;AACA,2D;AACA,gC;;AAEA,oD;AACA,e;AACA,8B;;AAEA,oC;AACA,iE;AACA,6B;AACA,mB;AACA,a;AACA,+B;AACA,C;;AAEA,sB;AACA,gC;AACA,uC;AACA,+D;AACA,C;;AAEA,sB;AACA,gC;AACA,gC;AACA,8B;AACA,C;;;AAGA,sB;AACA,gC;AACA,6D;AACA,8B;AACA,C;;AAEA,wB;;AAEA,iC;AACA,kC;AACA,gC;AACA,qB;AACA,Q;AACA,gC;AACA,2C;AACA,uD;AACA,G;;AAEA,gC;AACA,sC;;AAEA,kC;AACA,qB;AACA,6D;;AAEA,S;AACA,uD;;AAEA,qB;;AAEA,+B;AACA,qB;AACA,qB;AACA,qB;;AAEA,yC;AACA,Y;AACA,yB;AACA,M;AACA,wD;AACA,8C;AACA,O;;AAEA,2C;AACA,gB;AACA,C;;AAEA,sC;AACA,kE;AACA,6B;AACA,oD;AACA,sB;AACA,E;;AAEA,uC;AACA,mC;AACA,E;;AAEA,wC;AACA,sB;AACA,E;;AAEA,4C;AACA,2D;AACA,iC;AACA,0C;;AAEA,2D;AACA,E;;AAEA,gD;AACA,iC;AACA,0C;;AAEA,uD;AACA,uD;AACA,qD;AACA,E;;AAEA,+C;AACA,iC;AACA,0C;;AAEA,4C;AACA,yD;AACA,c;AACA,8D;AACA,a;AACA,+D;AACA,a;;AAEA,Y;AACA,M;AACA,+B;AACA,gC;AACA,yC;AACA,2C;AACA,e;AACA,6B;AACA,e;AACA,6B;AACA,gB;AACA,qB;AACA,e;AACA,Q;AACA,sC;AACA,gB;AACA,E;;AAEA,+E;AACA,gE;AACA,sD;AACA,oB;AACA,oB;AACA,iC;AACA,qB;AACA,qB;AACA,mB;AACA,kC;AACA,Y;AACA,oB;AACA,iC;AACA,qB;AACA,mB;AACA,kC;AACA,Y;AACA,oB;AACA,0E;AACA,0E;AACA,gC;AACA,iC;AACA,oC;AACA,kC;AACA,Y;AACA,sE;AACA,gB;AACA,sB;AACA,uC;AACA,sC;AACA,kC;AACA,Y;;AAEA,iB;AACA,2E;AACA,mC;AACA,+B;AACA,6B;AACA,+E;AACA,qB;AACA,qB;AACA,qB;AACA,2B;AACA,Y;AACA,iB;AACA,2E;AACA,mC;AACA,+B;AACA,6B;AACA,2D;AACA,qB;AACA,qB;AACA,2B;AACA,Y;AACA,iB;AACA,2E;AACA,0E;AACA,iC;AACA,+B;AACA,uC;AACA,qB;AACA,2B;AACA,Y;AACA,gD;AACA,qE;AACA,e;AACA,uC;AACA,8B;AACA,Y;AACA,uC;AACA,0B;AACA,uD;AACA,iC;AACA,mB;AACA,W;AACA,S;AACA,kD;AACA,kC;AACA,O;AACA,uB;AACA,8C;AACA,gE;AACA,gD;AACA,wC;AACA,8C;AACA,c;AACA,4C;AACA,O;AACA,Y;;AAEA,Y;AACA,gE;AACA,G;AACA,gB;AACA,c;AACA,E;;AAEA,kB;AACA,mD;AACA,mC;AACA,uB;AACA,sB;AACA,G;;AAEA,O;AACA,uE;AACA,gB;AACA,gB;AACA,G;AACA,C;;AAEA,gD;;AAEA,yB;AACA,mC;AACA,6B;AACA,6B;;AAEA,qB;AACA,W;AACA,W;AACA,G;;AAEA,+B;AACA,8B;AACA,qB;AACA,oB;AACA,W;AACA,C;;AAEA,kD;AACA,oC;AACA,kC;AACA,C;;AAEA,0B;AACA,+B;AACA,yC;AACA,C;;AAEA,oC;AACA,6B;AACA,6B;AACA,C;;AAEA,4B;AACA,gC;AACA,8B;AACA,C;;AAEA,oB;AACA,4B;AACA,mC;AACA,wC;AACA,K;AACA,C;;AAEA,sB;AACA,6B;AACA,mC;AACA,yC;AACA,K;AACA,C;;AAEA,gB;AACA,0B;AACA,kC;AACA,C;;AAEA,gB;AACA,0B;AACA,kC;AACA,C;;AAEA,gB;AACA,0B;AACA,oC;AACA,C;;AAEA,kB;AACA,2B;AACA,oC;AACA,C;;AAEA,kB;AACA,2B;AACA,mC;AACA,C;;AAEA,kB;AACA,2B;AACA,mC;AACA,C;;AAEA,kB;AACA,+B;AACA,U;AACA,e;AACA,e;AACA,+C;AACA,+C;AACA,oB;AACA,Y;AACA,e;AACA,+C;AACA,+C;AACA,oB;AACA,Y;AACA,+D;AACA,6C;AACA,2C;AACA,6C;AACA,2C;AACA,6C;AACA,4D;AACA,G;AACA,a;AACA,C;;AAEA,gC;AACA,kC;AACA,mC;AACA,6B;AACA,kB;AACA,Q;AACA,wB;AACA,G;;AAEA,oC;AACA,uC;;AAEA,mC;AACA,qB;AACA,mB;;AAEA,0B;AACA,oB;AACA,M;AACA,qD;;AAEA,sB;AACA,C;;AAEA,a;AACA,6C;AACA,4D;AACA,wB;;AAEA,S;AACA,uD;;AAEA,uB;AACA,4B;AACA,uB;;AAEA,2D;AACA,Y;AACA,sB;AACA,M;AACA,+C;AACA,E;;AAEA,2C;AACA,8C;AACA,E;;AAEA,4C;AACA,oB;AACA,E;;AAEA,+C;AACA,gD;;AAEA,0B;AACA,gB;;AAEA,kC;AACA,8C;;AAEA,8D;AACA,E;;;AAGA,sB;AACA,8B;AACA,wD;AACA,iB;;AAEA,+B;AACA,mC;;AAEA,qB;;AAEA,wC;AACA,mB;AACA,4D;AACA,yC;AACA,+B;AACA,8D;AACA,oB;AACA,K;;AAEA,yB;AACA,0D;AACA,G;;AAEA,gB;AACA,C;;AAEA,sC;AACA,+C;AACA,E;;AAEA,qC;AACA,6C;AACA,kC;AACA,uB;AACA,oB;AACA,E;;AAEA,uC;AACA,oB;AACA,E;;AAEA,8C;AACA,yB;AACA,uB;AACA,+B;AACA,yC;AACA,0D;AACA,2C;AACA,iC;AACA,yC;AACA,mE;AACA,sD;;AAEA,0B;AACA,yD;;AAEA,0B;AACA,yD;;AAEA,qB;AACA,uC;;AAEA,uD;AACA,wC;;AAEA,4D;AACA,iD;AACA,wC;AACA,4B;AACA,mB;AACA,kE;AACA,qC;AACA,kC;AACA,O;AACA,G;AACA,gC;AACA,uC;AACA,K;;AAEA,a;AACA,E;;AAEA,iD;AACA,sC;AACA,sC;AACA,yD;AACA,iC;AACA,qB;AACA,mC;AACA,K;AACA,C;;AAEA,iE;AACA,qC;AACA,uC;AACA,uC;AACA,sB;AACA,oC;AACA,uB;AACA,oC;AACA,wB;AACA,qC;AACA,wB;AACA,mC;AACA,uB;AACA,c;AACA,C;;AAEA,kB;AACA,uD;AACA,C;;AAEA,iC;AACA,0D;AACA,kD;AACA,kD;AACA,qC;AACA,qC;AACA,qC;AACA,sD;AACA,qC;AACA,e;AACA,C;;AAEA,oC;AACA,6C;AACA,mD;AACA,yC;AACA,Y;;AAEA,e;AACA,e;AACA,oB;AACA,oD;AACA,oB;AACA,iC;AACA,oE;AACA,kB;AACA,mC;AACA,+B;AACA,sB;AACA,+C;AACA,6C;AACA,U;AACA,iC;AACA,0C;AACA,6C;;AAEA,+B;AACA,e;AACA,K;AACA,C;;AAEA,6B;AACA,sC;AACA,kC;AACA,kC;AACA,4B;AACA,4B;AACA,qC;AACA,sD;AACA,qC;AACA,e;AACA,C;;AAEA,oC;AACA,8B;AACA,6C;AACA,mD;AACA,yC;AACA,Y;;AAEA,e;AACA,e;AACA,oB;AACA,oD;AACA,sB;AACA,oB;AACA,sE;AACA,U;AACA,8D;AACA,oB;AACA,mC;AACA,+B;AACA,sB;AACA,sB;AACA,sB;AACA,mD;AACA,oD;AACA,Y;AACA,mD;AACA,iD;AACA,Y;AACA,iD;AACA,uC;AACA,Y;AACA,qB;AACA,sB;AACA,sB;AACA,8C;AACA,oD;AACA,Y;AACA,8C;AACA,iD;AACA,Y;AACA,4C;AACA,uC;AACA,K;;AAEA,+B;AACA,e;AACA,K;AACA,C;;AAEA,sC;AACA,uC;AACA,+C;AACA,sC;AACA,e;AACA,C;;AAEA,qC;AACA,qB;AACA,+C;AACA,2D;AACA,kD;AACA,oB;AACA,0B;AACA,0B;AACA,kB;;AAEA,6B;AACA,gB;;AAEA,a;AACA,yC;AACA,6B;AACA,uB;AACA,c;AACA,+B;AACA,kB;AACA,O;AACA,8B;AACA,yB;AACA,a;AACA,c;AACA,a;AACA,c;;AAEA,yB;AACA,wB;AACA,0B;AACA,6B;AACA,oB;AACA,iB;AACA,qB;AACA,gB;AACA,gB;AACA,wB;AACA,qB;AACA,gB;AACA,S;AACA,iC;AACA,6D;AACA,2D;AACA,kB;AACA,e;AACA,oB;AACA,Y;AACA,oB;AACA,O;;AAEA,yC;AACA,oB;AACA,oD;AACA,oB;AACA,oE;AACA,K;;AAEA,gC;;AAEA,e;AACA,K;AACA,C;;AAEA,8D;AACA,2D;AACA,oC;AACA,qC;AACA,oE;AACA,2C;AACA,C;;AAEA,6D;AACA,iC;AACA,iC;AACA,kD;AACA,8B;AACA,0B;AACA,iD;AACA,iD;;AAEA,c;AACA,c;AACA,mB;AACA,8B;AACA,mB;AACA,uC;AACA,M;AACA,uB;;AAEA,c;AACA,Y;AACA,mB;AACA,kC;AACA,mB;AACA,2C;AACA,e;AACA,qD;AACA,M;AACA,mB;;AAEA,kC;AACA,C;;;AAGA,6D;AACA,0C;AACA,e;AACA,iB;;AAEA,kC;AACA,8C;;AAEA,6C;AACA,sC;AACA,kB;AACA,G;AACA,e;AACA,E;;AAEA,gC;AACA,wC;AACA,8B;AACA,mB;AACA,G;;AAEA,kC;AACA,oE;AACA,+D;AACA,8C;AACA,6D;AACA,gE;AACA,0C;AACA,2B;AACA,gC;AACA,oB;;AAEA,gD;AACA,oC;AACA,8C;AACA,8C;AACA,4C;AACA,sB;AACA,O;AACA,K;;AAEA,gE;AACA,iB;AACA,G;;AAEA,c;AACA,C;;AAEA,8B;AACA,2C;AACA,O;AACA,oC;AACA,gB;AACA,iB;AACA,G;AACA,6B;AACA,C;;AAEA,sC;AACA,gD;AACA,4C;AACA,4C;AACA,0B;AACA,iC;AACA,gB;AACA,C;;AAEA,gC;AACA,mC;AACA,O;AACA,yD;AACA,6C;AACA,gD;AACA,gB;AACA,gB;AACA,G;AACA,C;;AAEA,2E;AACA,kB;AACA,qC;AACA,6C;AACA,C;;AAEA,+E;AACA,kB;AACA,qC;AACA,6C;AACA,C;;AAEA,0B;AACA,+C;AACA,uC;AACA,kC;;AAEA,qC;AACA,iB;AACA,a;AACA,gB;AACA,kB;AACA,gB;AACA,iB;AACA,mB;AACA,Y;AACA,a;AACA,gB;AACA,kB;AACA,gB;AACA,iB;AACA,mB;AACA,Y;AACA,Y;AACA,mE;AACA,G;;AAEA,gD;AACA,yC;AACA,iB;AACA,G;;AAEA,+D;AACA,gE;;AAEA,8C;AACA,mC;;AAEA,oB;AACA,mB;;AAEA,8C;AACA,gC;AACA,8B;AACA,wD;AACA,0B;AACA,8D;AACA,yB;AACA,O;AACA,O;;AAEA,qE;AACA,uB;AACA,4D;AACA,mB;AACA,K;;AAEA,uE;AACA,0D;AACA,mD;AACA,qC;AACA,mB;AACA,qE;AACA,mB;AACA,K;AACA,G;AACA,c;AACA,C;;AAEA,iD;AACA,+C;AACA,kB;;;;;;;;;;;;;;;;;;;AC9mCA,wE;AACA,+E;AACA,8E;AACA,8E;AACA,S;AACA,4C;;;AAGA,qB;AACA,mE;AACA,8E;;AAEA,oE;AACA,E;AACA,+C;AACA,0B;AACA,0B;AACA,0B;AACA,4D;AACA,4B;AACA,6C;AACA,iD;AACA,iE;AACA,6E;AACA,E;AACA,uE;AACA,mE;AACA,yD;AACA,sD;AACA,E;AACA,sD;AACA,E;AACA,2E;AACA,mC;AACA,8C;AACA,yE;AACA,G;AACA,wB;AACA,mE;AACA,G;;AAEA,oE;AACA,qE;AACA,qC;AACA,2C;AACA,0C;AACA,kB;;AAEA,6B;AACA,6E;AACA,G;AACA,6B;AACA,6E;AACA,G;AACA,6B;AACA,2B;AACA,oB;AACA,6D;AACA,wC;AACA,8B;AACA,mE;AACA,0C;AACA,oC;AACA,8B;AACA,uE;AACA,0C;AACA,K;AACA,oC;AACA,G;;AAEA,oE;AACA,uB;AACA,gC;AACA,6B;AACA,qC;AACA,G;;AAEA,8E;AACA,4E;AACA,oD;AACA,4B;AACA,gE;AACA,gC;AACA,I;;AAEA,6C;AACA,sB;AACA,4B;AACA,gE;AACA,6B;AACA,G;;AAEA,2C;AACA,2C;AACA,2C;AACA,sE;AACA,mC;AACA,6C;AACA,wD;AACA,+D;AACA,iE;AACA,gC;AACA,sE;AACA,wC;AACA,uC;AACA,uE;AACA,E;;AAEA,qC;AACA,+B;AACA,E;;AAEA,a;AACA,sB;AACA,Q;AACA,sB;AACA,C;;AAEA,sE;AACA,8D;AACA,mD;AACA,wD;AACA,E;AACA,8E;AACA,e;AACA,yE;AACA,qE;AACA,wE;AACA,gD;AACA,6E;AACA,6E;AACA,6C;AACA,E;AACA,sE;AACA,6D;AACA,kE;AACA,mB;AACA,+D;AACA,gE;AACA,gD;AACA,kC;;AAEA,8B;AACA,mB;AACA,a;AACA,qB;AACA,6D;AACA,E;;AAEA,mE;AACA,mE;AACA,mD;AACA,4D;AACA,8B;AACA,a;;AAEA,6D;AACA,c;AACA,mC;AACA,qB;AACA,0C;AACA,4B;AACA,8E;;AAEA,6C;AACA,kD;AACA,0B;AACA,kF;AACA,Y;AACA,wB;AACA,Q;;AAEA,yF;AACA,8D;AACA,mD;AACA,Y;AACA,oG;AACA,K;;AAEA,6C;AACA,iE;AACA,+C;AACA,kD;AACA,S;AACA,E;;AAEA,uF;AACA,kD;AACA,iD;AACA,gD;AACA,E;;AAEA,8E;AACA,4E;AACA,kB;AACA,E;AACA,8C;AACA,4C;AACA,uC;AACA,E;;AAEA,4E;AACA,kD;AACA,kD;AACA,gD;AACA,sB;AACA,+B;AACA,sB;AACA,G;AACA,sB;AACA,+B;AACA,sB;AACA,G;;AAEA,0E;AACA,yE;AACA,0B;AACA,gC;AACA,gD;AACA,U;AACA,6E;AACA,0B;AACA,mC;AACA,G;AACA,E;;AAEA,mD;AACA,6E;AACA,wE;AACA,oC;AACA,6B;AACA,4E;AACA,mB;AACA,+B;AACA,4B;AACA,0E;AACA,0E;AACA,2E;AACA,yE;AACA,4B;AACA,yD;AACA,2B;AACA,iD;AACA,G;;AAEA,0B;;AAEA,2C;AACA,qB;AACA,+C;AACA,U;AACA,6B;AACA,qC;AACA,G;;AAEA,sD;AACA,0C;;AAEA,sD;AACA,E;;;AAGA,+E;AACA,E;AACA,oE;AACA,+E;AACA,8B;AACA,2D;AACA,+C;AACA,E;;AAEA,qD;AACA,mB;AACA,8D;AACA,kC;AACA,4B;AACA,uD;AACA,kB;AACA,0D;AACA,2B;AACA,U;AACA,mC;AACA,oD;AACA,iD;AACA,kB;AACA,+D;AACA,mD;AACA,O;AACA,wC;AACA,O;AACA,G;;AAEA,+B;AACA,mC;AACA,E;;AAEA,yD;AACA,oD;AACA,E;;AAEA,2E;AACA,8D;AACA,8D;AACA,sE;AACA,sC;AACA,gD;AACA,oC;AACA,8C;AACA,oD;AACA,yD;AACA,G;;AAEA,wD;AACA,c;AACA,wB;AACA,gD;AACA,gC;AACA,Y;AACA,gC;AACA,K;AACA,uC;AACA,uE;AACA,sD;AACA,uD;AACA,2B;AACA,iC;AACA,8B;AACA,8B;AACA,0D;AACA,gF;AACA,0B;AACA,K;AACA,U;AACA,wB;AACA,2B;AACA,G;;AAEA,sC;AACA,0B;AACA,8C;AACA,U;AACA,qE;AACA,G;;AAEA,6B;AACA,4C;AACA,6C;AACA,E;;AAEA,uD;AACA,yB;AACA,8B;AACA,uC;AACA,G;AACA,a;AACA,E;;AAEA,oC;AACA,E;AACA,2B;AACA,qB;AACA,8B;AACA,kD;AACA,mB;AACA,kD;AACA,uC;AACA,qD;AACA,gD;AACA,E;;AAEA,0D;AACA,0B;;AAEA,mD;AACA,gB;AACA,2C;AACA,8B;AACA,wE;AACA,iF;AACA,0E;AACA,gF;AACA,K;AACA,4B;AACA,8E;AACA,kE;AACA,G;AACA,mC;AACA,kF;AACA,2D;AACA,G;AACA,+B;AACA,qE;AACA,2D;AACA,G;AACA,sC;AACA,mE;AACA,2D;AACA,G;;AAEA,sC;AACA,sE;AACA,yD;AACA,G;AACA,uC;AACA,oF;AACA,yD;AACA,G;AACA,+B;AACA,2E;AACA,yD;AACA,G;AACA,mF;AACA,uD;;AAEA,+D;AACA,iF;AACA,yD;AACA,G;AACA,E;;AAEA,kD;AACA,6B;AACA,8B;AACA,U;AACA,E;;AAEA,mE;AACA,4B;AACA,E;AACA,wE;AACA,6C;AACA,8D;AACA,qC;AACA,uE;AACA,mE;AACA,4E;AACA,uB;AACA,sC;AACA,sC;AACA,E;;AAEA,0C;AACA,6C;AACA,4C;AACA,E","file":"/packages/package-version-parser.js","sourcesContent":["// <METEOR>\n// Fool the module system detection code below so that it doesn't\n// do anything special.\nvar exports = SemVer, module = {}, define = {};\n// Create a package-private variable.  Can't use SemVer because\n// of the code that says `function SemVer(...)` below (implicitly\n// declaring a var).  Can't use \"semver\" because that's a var in\n// package-version-parser.js.\nSemVer410 = SemVer;\n// </METEOR>\n\n// export the class if we are in a Node-like system.\nif (typeof module === 'object' && module.exports === exports)\n  exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  var r = loose ? re[LOOSE] : re[FULL];\n  return (r.test(version)) ? new SemVer(version, loose) : null;\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      return (/^[0-9]+$/.test(id)) ? +id : id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.inspect = function() {\n  return '<SemVer \"' + this + '\">';\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.inspect = function() {\n  return '<SemVer Comparator \"' + this + '\">';\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.inspect = function() {\n  return '<SemVer Range \"' + this.range + '\">';\n};\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0- <1.3.0-\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm)\n          M = +M + 1\n        else\n          m = +m + 1\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        return true;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Use the define() function if we're in AMD land\nif (typeof define === 'function' && define.amd)\n  define(exports);\n","// This file is in tools/package-version-parser.js and is symlinked into\n// packages/package-version-parser/package-version-parser.js. It's part of both\n// the tool and the package!  We don't use an isopacket for it because it used\n// to be required as part of building isopackets (though that may no longer be\n// true).\nvar inTool = typeof Package === 'undefined';\n\n\nvar semver = inTool ?\n  require ('../../dev_bundle/lib/node_modules/semver') : SemVer410;\nvar __ = inTool ? require('../../dev_bundle/lib/node_modules/underscore') : _;\n\n// Takes in a meteor version string, for example 1.2.3-rc.5_1+12345.\n//\n// Returns an object composed of the following:\n//  * major (integer >= 0)\n//  * minor (integer >= 0)\n//  * patch (integer >= 0)\n//  * prerelease (Array of Number-or-String, possibly empty)\n//  * wrapNum (integer >= 0)\n//  * build (Array of String, possibly empty)\n//  * raw (String), the raw meteor version string\n//  * version (String), canonical meteor version without build ID\n//  * semver (String), canonical semver version with build ID but no wrap num\n//\n// The input string \"1.2.3-rc.5_1+12345\" has a (major, minor, patch) of\n// (1, 2, 3), a prerelease of [\"rc\", 5], a wrapNum of 1, a build of\n// [\"12345\"], a raw of \"1.2.3-rc.5_1+12345\", a version of\n// \"1.2.3-rc.5_1\", and a semver of \"1.2.3-rc.5+12345\".\n//\n// Throws if the version string is invalid in any way.\n//\n// You can write `PV.parse(\"1.2.3\")` as an alternative to `new PV(\"1.2.3\")`\nvar PV = function (versionString) {\n  if (! (typeof versionString === 'string')) {\n    throw new Error(\"Invalid PackageVersion argument: \" + versionString);\n  }\n  if (! versionString) {\n    throwVersionParserError(\"Empty string is not a valid version\");\n  }\n\n  // The buildID (\"+foo\" suffix) is part of semver, but split it off\n  // because it comes after the wrapNum.  The wrapNum (\"_123\" suffix)\n  // is a Meteor extension to semver.\n  var plusSplit = versionString.split('+');\n  var wrapSplit = plusSplit[0].split('_');\n  var wrapNum = 0;\n\n  if (plusSplit.length > 2) {\n    throwVersionParserError(\"Can't have two + in version: \" + versionString);\n  }\n  if (wrapSplit.length > 2) {\n    throwVersionParserError(\"Can't have two _ in version: \" + versionString);\n  }\n  if (wrapSplit.length > 1) {\n    wrapNum = wrapSplit[1];\n    if (! wrapNum) {\n      throwVersionParserError(\"A wrap number must follow _\");\n    } else if (!/^\\d+$/.test(wrapNum)) {\n      throwVersionParserError(\n        \"The wrap number (after _) must contain only digits, so \" +\n          versionString + \" is invalid.\");\n    } else if (wrapNum[0] === \"0\") {\n      throwVersionParserError(\n        \"The wrap number (after _) must not have a leading zero, so \" +\n          versionString + \" is invalid.\");\n    }\n    wrapNum = parseInt(wrapNum, 10);\n  }\n\n  // semverPart is everything but the wrapNum, so for \"1.0.0_2+xyz\",\n  // it is \"1.0.0+xyz\".\n  var semverPart = wrapSplit[0];\n  if (plusSplit.length > 1) {\n    semverPart += \"+\" + plusSplit[1];\n  }\n\n  // NPM's semver spec supports things like 'v1.0.0' and considers them valid,\n  // but we don't. Everything before the + or - should be of the x.x.x form.\n  if (! /^\\d+\\.\\d+\\.\\d+(\\+|-|$)/.test(semverPart)) {\n    throwVersionParserError(\n      \"Version string must look like semver (eg '1.2.3'), not '\"\n        + versionString + \"'.\");\n  };\n\n  var semverParse = semver.parse(semverPart);\n  if (! semverParse) {\n    throwVersionParserError(\n      \"Version string must look like semver (eg '1.2.3'), not '\"\n        + semverPart + \"'.\");\n  }\n\n  this.major = semverParse.major; // Number\n  this.minor = semverParse.minor; // Number\n  this.patch = semverParse.patch; // Number\n  this.prerelease = semverParse.prerelease; // [OneOf(Number, String)]\n  this.wrapNum = wrapNum; // Number\n  this.build = semverParse.build; // [String]\n  this.raw = versionString; // the entire version string\n  // `.version` is everything but the build ID (\"+foo\"), and it\n  // has been run through semver's canonicalization, ie \"cleaned\"\n  // (for whatever that's worth)\n  this.version = semverParse.version + (wrapNum ? '_' + wrapNum : '');\n  // everything but the wrapnum (\"_123\")\n  this.semver = semverParse.version + (\n    semverParse.build.length ? '+' + semverParse.build.join('.') : '');\n};\n\nPV.parse = function (versionString) {\n  return new PV(versionString);\n};\n\nif (inTool) {\n  module.exports = PV;\n} else {\n  PackageVersion = PV;\n}\n\n// Converts a meteor version into a large floating point number, which\n// is (more or less [*]) unique to that version. Satisfies the\n// following guarantee: If PV.lessThan(v1, v2) then\n// PV.versionMagnitude(v1) < PV.versionMagnitude(v2) [*]\n//\n// [* XXX!] We don't quite satisfy the uniqueness and comparison properties in\n// these cases:\n// 1. If any of the version parts are greater than 100 (pretty unlikely?)\n// 2. If we're dealing with a prerelease version, we only look at the\n//    first two characters of each prerelease part. So, \"1.0.0-beta\" and\n//    \"1.0.0-bear\" will have the same magnitude.\n// 3. If we're dealing with a prerelease version with more than two parts, eg\n//    \"1.0.0-rc.0.1\". In this comparison may fail since we'd get to the limit\n//    of JavaScript floating point precision.\n//\n// If we wanted to fix this, we'd make this function return a BigFloat\n// instead of a vanilla JavaScript number. That will make the\n// constraint solver slower (by how much?), and would require some\n// careful thought.\n// (Or it could just return some sort of tuple, and ensure that\n// the cost functions that consume this can deal with tuples...)\nPV.versionMagnitude = function (versionString) {\n  var v = PV.parse(versionString);\n\n  return v.major * 100 * 100 +\n    v.minor * 100 +\n    v.patch +\n    v.wrapNum / 100 +\n    prereleaseIdentifierToFraction(v.prerelease) / 100 / 100;\n};\n\n// Accepts an array, eg [\"rc\", 2, 3]. Returns a number in the range\n// (-1, 0].  An empty array returns 0. A non-empty string returns a\n// number that is \"as large\" as the its precedence.\nvar prereleaseIdentifierToFraction = function (prerelease) {\n  if (prerelease.length === 0)\n    return 0;\n\n  return __.reduce(prerelease, function (memo, part, index) {\n    var digit;\n    if (typeof part === 'number') {\n      digit = part+1;\n    } else if (typeof part === 'string') {\n      var VALID_CHARACTERS =\n            \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n      var validCharToNumber = function (ch) {\n        var result = VALID_CHARACTERS.indexOf(ch);\n        if (result === -1)\n          throw new Error(\"Unexpected character in prerelease identifier: \" + ch);\n        else\n          return result;\n      };\n\n      digit = 101 + // Numeric parts always have lower precedence than non-numeric parts.\n        validCharToNumber(part[0]) * VALID_CHARACTERS.length +\n        (part[1] ? validCharToNumber(part[1]) : 0);\n    } else {\n      throw new Error(\"Unexpected prerelease identifier part: \" + part + \" of type \" + typeof part);\n    }\n\n    // 4100 > 101 + VALID_CHARACTERS.length *\n    // VALID_CHARACTERS.length. And there's a test to verify this\n    // (\"test the edges of `versionMagnitude`\")\n    return memo + digit / Math.pow(4100, index+1);\n  }, -1);\n};\n\n// Takes in two meteor versions. Returns true if the first one is less than the second.\n// Versions are strings or PackageVersion objects.\nPV.lessThan = function (versionOne, versionTwo) {\n  return PV.compare(versionOne, versionTwo) < 0;\n};\n\n// Given a string version, returns its major version (the first section of the\n// semver), as an integer. Two versions are compatible if they have the same\n// version number.\n//\n// versionString: valid meteor version string.\nPV.majorVersion = function (versionString) {\n  return PV.parse(versionString).major;\n};\n\n// Takes in two meteor versions. Returns 0 if equal, a positive number if v1\n// is greater, a negative number if v2 is greater.\n// Versions are strings or PackageVersion objects.\nPV.compare = function (versionOne, versionTwo) {\n  var v1 = versionOne;\n  if (typeof v1 === 'string') {\n    v1 = PV.parse(v1);\n  }\n  var v2 = versionTwo;\n  if (typeof v2 === 'string') {\n    v2 = PV.parse(v2);\n  }\n\n  // If the semver parts are different, use the semver library to compare,\n  // ignoring wrap numbers.  (The semver library will ignore the build ID\n  // per the semver spec.)\n  if (v1.semver !== v2.semver) {\n    return semver.compare(v1.semver, v2.semver);\n  } else {\n    // If the semver components are equal, then the one with the smaller wrap\n    // numbers is smaller.\n    return v1.wrapNum - v2.wrapNum;\n  }\n};\n\n// Conceptually we have three types of constraints:\n// 1. \"compatible-with\" - A@x.y.z - constraints package A to version x.y.z or\n//    higher, as long as the version is backwards compatible with x.y.z.\n//    \"pick A compatible with x.y.z\"\n//    It is the default type.\n// 2. \"exactly\" - A@=x.y.z - constraints package A only to version x.y.z and\n//    nothing else.\n//    \"pick A exactly at x.y.z\"\n// 3. \"any-reasonable\" - \"A\"\n//    Basically, this means any version of A ... other than ones that have\n//    dashes in the version (ie, are prerelease) ... unless the prerelease\n//    version has been explicitly selected (which at this stage in the game\n//    means they are mentioned in a top-level constraint in the top-level\n//    call to the resolver).\nvar parseSimpleConstraint = function (constraintString) {\n  if (! constraintString) {\n    throw new Error(\"Non-empty string required\");\n  }\n\n  var type, versionString;\n\n  if (constraintString.charAt(0) === '=') {\n    type = \"exactly\";\n    versionString = constraintString.substr(1);\n  } else {\n    type = \"compatible-with\";\n    versionString = constraintString;\n  }\n\n  // This will throw if the version string is invalid.\n  PV.getValidServerVersion(versionString);\n\n  return { type: type, versionString: versionString };\n};\n\n\n// Check to see if the versionString that we pass in is a valid meteor version.\n//\n// Returns a valid meteor version string that can be included in the\n// server. That means that it has everything EXCEPT the build id. Throws if the\n// entered string was invalid.\nPV.getValidServerVersion = function (meteorVersionString) {\n  return PV.parse(meteorVersionString).version;\n};\n\nPV.VersionConstraint = function (vConstraintString) {\n  var alternatives;\n  // If there is no version string (\"\" or null), then our only\n  // constraint is any-reasonable.\n  if (! vConstraintString) {\n    // .versionString === null is relied on in the tool\n    alternatives =\n      [ { type: \"any-reasonable\", versionString: null } ];\n    vConstraintString = \"\";\n  } else {\n    // Parse out the versionString.\n    var parts = vConstraintString.split(/ *\\|\\| */);\n    alternatives = __.map(parts, function (alt) {\n      if (! alt) {\n        throwVersionParserError(\"Invalid constraint string: \" +\n                                vConstraintString);\n      }\n      return parseSimpleConstraint(alt);\n    });\n  }\n\n  this.raw = vConstraintString;\n  this.alternatives = alternatives;\n};\n\nPV.parseVersionConstraint = function (constraintString) {\n  return new PV.VersionConstraint(constraintString);\n};\n\n// A PackageConstraint consists of a package name and a version constraint.\n// Call either with args (package, versionConstraintString) or\n// (packageConstraintString), or (package, versionConstraint).\n// That is, (\"foo\", \"1.2.3\") or (\"foo@1.2.3\"), or (\"foo\", vc) where vc\n// is instanceof PV.VersionConstraint.\nPV.PackageConstraint = function (part1, part2) {\n  if ((typeof part1 !== \"string\") ||\n      (part2 && (typeof part2 !== \"string\") &&\n       ! (part2 instanceof PV.VersionConstraint))) {\n    throw new Error(\"constraintString must be a string\");\n  }\n\n  var packageName, versionConstraint, vConstraintString;\n  if (part2) {\n    packageName = part1;\n    if (part2 instanceof PV.VersionConstraint) {\n      versionConstraint = part2;\n    } else {\n      vConstraintString = part2;\n    }\n  } else if (part1.indexOf(\"@\") >= 0) {\n    // Shave off last part after @, with \"a@b@c\" becoming [\"a@b\", \"c\"].\n    // Validating the package name will catch extra @.\n    var parts = part1.match(/^(.*)@([^@]*)$/).slice(1);\n    packageName = parts[0];\n    vConstraintString = parts[1];\n    if (! vConstraintString) {\n      throwVersionParserError(\n        \"Version constraint for package '\" + packageName +\n          \"' cannot be empty; leave off the @ if you don't want to constrain \" +\n          \"the version.\");\n    }\n  } else {\n    packageName = part1;\n    vConstraintString = \"\";\n  }\n\n  PV.validatePackageName(packageName);\n  if (versionConstraint) {\n    vConstraintString = versionConstraint.raw;\n  } else {\n    versionConstraint = PV.parseVersionConstraint(vConstraintString);\n  }\n\n  this.package = packageName;\n  this.constraintString = vConstraintString;\n  this.versionConstraint = versionConstraint;\n};\n\nPV.PackageConstraint.prototype.toString = function () {\n  var ret = this.package;\n  if (this.constraintString) {\n    ret += \"@\" + this.constraintString;\n  }\n  return ret;\n};\n\n// Structure of a parsed constraint:\n//\n// /*PV.PackageConstraint*/\n// { package: String,\n//   constraintString: String,\n//   versionConstraint: /*PV.VersionConstraint*/ {\n//     raw: String,\n//     alternatives: [{versionString: String|null,\n//                     type: String}]}}\nPV.parsePackageConstraint = function (part1, part2) {\n  return new PV.PackageConstraint(part1, part2);\n};\n\nPV.validatePackageName = function (packageName, options) {\n  options = options || {};\n\n  var badChar = packageName.match(/[^a-z0-9:.\\-]/);\n  if (badChar) {\n    if (options.detailedColonExplanation) {\n      throwVersionParserError(\n        \"Bad character in package name: \" + JSON.stringify(badChar[0]) +\n          \".\\n\\nPackage names can only contain lowercase ASCII alphanumerics, \" +\n          \"dash, or dot.\\nIf you plan to publish a package, it must be \" +\n          \"prefixed with your\\nMeteor Developer Account username and a colon.\");\n    }\n    throwVersionParserError(\n      \"Package names can only contain lowercase ASCII alphanumerics, dash, \" +\n        \"dot, or colon, not \" + JSON.stringify(badChar[0]) + \".\");\n  }\n  if (!/[a-z]/.test(packageName)) {\n    throwVersionParserError(\"Package name must contain a lowercase ASCII letter: \"\n                            + JSON.stringify(packageName));\n  }\n  if (packageName[0] === '.') {\n    throwVersionParserError(\"Package name may not begin with a dot: \"\n                            + JSON.stringify(packageName));\n  }\n  if (packageName.slice(-1) === '.') {\n    throwVersionParserError(\"Package name may not end with a dot: \"\n                            + JSON.stringify(packageName));\n  }\n\n  if (packageName.slice(-1) === '.') {\n    throwVersionParserError(\"Package names may not end with a dot: \" +\n                            JSON.stringify(packageName));\n  }\n  if (packageName.indexOf('..') >= 0) {\n    throwVersionParserError(\"Package names may not contain two consecutive dots: \" +\n                            JSON.stringify(packageName));\n  }\n  if (packageName[0] === '-') {\n    throwVersionParserError(\"Package names may not begin with a hyphen: \" +\n                            JSON.stringify(packageName));\n  }\n  // (There is already a package ending with a `-` and one with two consecutive `-`\n  // in troposphere, though they both look like typos.)\n\n  if (packageName[0] === \":\" || __.last(packageName) === \":\") {\n    throwVersionParserError(\"Package names may not start or end with a colon: \" +\n                            JSON.stringify(packageName));\n  }\n};\n\nvar throwVersionParserError = function (message) {\n  var e = new Error(message);\n  e.versionParserError = true;\n  throw e;\n};\n\n// Return true if the version constraint was invalid prior to 0.9.3\n// (adding _ and || support)\n//\n// NOTE: this is not used on the client yet. This package is used by the\n// package server to determine what is valid.\nPV.invalidFirstFormatConstraint = function (validConstraint) {\n  if (!validConstraint) return false;\n  // We can check this easily right now, because we introduced some new\n  // characters. Anything with those characters is invalid prior to\n  // 0.9.3. XXX: If we ever have to go through these, we should write a more\n  // complicated regex.\n  return (/_/.test(validConstraint) ||\n          /\\|/.test(validConstraint));\n};\n\n// Remove a suffix like \"+foo\" if present.\nPV.removeBuildID = function (versionString) {\n  return versionString.replace(/\\+.*$/, '');\n};\n"]}